<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>分布式锁 | HyperTars' Blog</title><meta name=keywords content="Distributed System,Distributed Lock,MySQL,Redis,Zookeeper"><meta name=description content="Distributed Lock"><meta name=author content="HyperTars"><link rel=canonical href=https://blog.hypertars.com/posts/developer/distributed_systems/lock/><link crossorigin=anonymous href=/assets/css/stylesheet.min.f34b707e96a5011787260c43994ea6cd89c86f5fef677a5e3c78f655715fd662.css integrity="sha256-80twfpalAReHJgxDmU6mzYnIb1/vZ3pePHj2VXFf1mI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.hypertars.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.hypertars.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.hypertars.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.hypertars.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.hypertars.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="分布式锁"><meta property="og:description" content="Distributed Lock"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.hypertars.com/posts/developer/distributed_systems/lock/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-15T00:00:00+08:00"><meta property="article:modified_time" content="2021-05-15T00:00:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="分布式锁"><meta name=twitter:description content="Distributed Lock"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Articles","item":"https://blog.hypertars.com/posts/"},{"@type":"ListItem","position":3,"name":"Developer","item":"https://blog.hypertars.com/posts/developer/"},{"@type":"ListItem","position":4,"name":"Distributed System","item":"https://blog.hypertars.com/posts/developer/distributed_systems/"},{"@type":"ListItem","position":5,"name":"分布式锁","item":"https://blog.hypertars.com/posts/developer/distributed_systems/lock/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"分布式锁","name":"分布式锁","description":"Distributed Lock","keywords":["Distributed System","Distributed Lock","MySQL","Redis","Zookeeper"],"articleBody":"分布式锁常见应用场景 防止缓存击穿\nRedis 的 Key 失效后，在查数据库前加一个分布式锁，查出来后把数据放到 Redis，保证大流量请求进来时，不会出现缓存击穿，只会有一个请求打到数据库。 保证接口幂等\n表单重复提交后没处理完，再次提交相当于提交了两份。提交后添加分布式锁，第一次提交的时候会锁住，第二次提交发现有锁，就不会继续执行业务逻辑。 任务调度\n分布式定时任务。可以通过分布式锁保证集群只执行一次任务。 分布式锁特征 高性能：分布式锁加锁和解锁不影响主业务逻辑，如果每次加锁和解锁都要花费几百 ms 是不能容忍的 可重入：对于同一个线程，要能重复加锁和解锁（可重入的条件是持有锁的线程是当前请求的线程），而不是阻塞等待卡死，重入几次就要释放几次。 互斥性 防死锁：锁不能及时释放会造成死锁，比如加锁了因为服务宕机了没有释放锁，可以给每把锁添加过期时间，这样即时服务意外宕机，等待一段时间后就会自动释放，避免死锁发生。\n实现分布式锁的常见方式 MySQL 实现分布式锁 实现原理 通过 MySQL 唯一索引实现，本质上是对于同一条数据的竞争操作，保证多点系统里同时只有一个执行线程进行处理（只能打到主库）。\n基于唯一索引实现（insert） 获取锁时在数据库中 insert 数据，插入成功即视为成功，互斥体现在插入重复数据会报错唯一 key 异常；释放时删除数据 缺点：强依赖数据库的可用性；没有超时保护，释放失败其他线程无法再次获取；并发压力 基于排它锁实现（for update） select .. for update 对查询过程中的数据表增加排它锁，其他线程无法再次增加排它锁，认为获得排它锁的线程获得分布式锁；释放时 commit，提交事务实现 缺点：强依赖数据库的可用性；排它锁占用连接，产生连接爆满问题，for update 连接阻塞；并发压力 需要考虑的设计细节\n分布式锁的表如何设计？唯一的锁 key 如何设计？可重入如何设计？ 可重入的关键在于需要一个字段存储重入次数，还要记住是哪个机器、哪个线程重入的 1 2 3 4 5 6 7 8 9 10 11 DROP TABLE IF EXISTS `common_lock`; CREATE TABLE `common_lock` ( `id` uint64 NOT NULL AUTO_INCREMENT, `lock_key` varchar(100) NOT NULL, `thread_id` int NOT NULL, `entry_count` int NOT NULL, `host_ip` varchar(30) NOT NULL, `lock_time` timestamp NOT NULL, PRIMARY KEY (`id`), UNIQUE KEY `lock_key` (`lock_key`) USING BTREE ) ENGINE = InnoDB DEFAULT CHARSET=utf8mb4; 如何判断重入逻辑？ 判断有没有锁，有锁再继续判断是不是自己加的锁，如果是自己的锁就更新 entry_count +1 抢锁失败后如何重试？ 死循环一直重试、重试到一定次数、重试一定时间，若持续加锁失败则退出 如何安全地释放锁？ 不可以直接删除 key，因为有重入情况。需要先判断重入次数，若大于 1 则减 1，若等于 1 才删除 防死锁设计？加锁成功，释放前系统宕机（需要考虑过期淘汰，防止无限膨胀） 起定时任务定时检查由于意外宕机或其他原因导致锁一直没释放的数据，若超过一定时间没释放，则自动释放 解决方案是记录加锁时间，定时扫描超出 n 秒还未释放的锁的数据，将其删除释放 删除超过 10 分钟没释放的锁 1 SELECT * FROM `common_lock` WHERE `lock_time` \u003c DATE_SUB(NOW(), INTERVAL 10 MINUTE); follow up：如果流程很耗时，执行结束前定时任务扫描认为锁超时提前释放，其他客户端成功上锁？ 单独起个线程进行定时续期（WatchDog） 优缺点 优点\n不需要引入其他中间件 缺点\n性能低、并发低 强依赖 MySQL，MySQL 不能出现单点故障 支持的锁种类有限而且使用不灵活，实现非公平锁容易，要实现公平锁需要模拟队列，实现读写锁则更为麻烦 Redis 实现分布式锁 实现原理 单节点分布式锁 核心是单机单线程，内存速度快。分布式 Redis Cluster 也会有锁不住的问题。主要基于 setnx(SET key ramdom_value NX PX time)，查看是否有响应键值对存在，若没有或过期则设置此键值对，若有则不会获得锁。 一般用 lua 脚本释放锁，保证原子性；先判断 redis 此时随机值 random_value 是否是之前客户端设置的，如果是则 del，否则不处理。 随机值：超时后被其他线程抢的锁不可释放 缺点：主从切换时多客户端认为自己有锁，就锁不住了。 RedLock（redis cluster） 核心针对高可用问题，解决单集群 Redis 宕机导致服务不可用以及集群 master 宕机，slave 节点尚未收到同步，导致多 client 获取到锁。 N 个单独部署的 Redis 集群，每个集群独立存在，无主从复制 获取锁的操作有一个超时时间，远小于锁的有效时间；向某个 redis 节点获取锁失败后，应立即尝试下一个 redis 节点。 计算整个获取锁的过程总共消耗了多长时间，如果客户端从大多数 redis 节点成功获取到了锁，并且总耗时没有超过锁的有效时间，那么才认为获取锁成功，否则认为获取锁失败。 锁的有效时间应当减去获取锁的消耗时间 如果获取锁失败了，客户端应该立即向所有 redis 节点发起释放锁操作（lua） 缺点：时钟漂移问题 Redisson（Java 客户端） 核心是使用 WatchDog 解决锁续期问题，屏蔽实现细节及实现可重入，等待申请锁资源的进程减少了无效的锁申请，提升资源利用率 使用 lua 脚本加锁，hash 数据类型的 key 包括当前线程信息、客户端信息，value 用于可重入计数；使用阻塞的方式减少锁的申请 使用 watchdog 每隔一定时间检查锁是否存在，存在就续期 使用 lua 脚本解锁，不存在的话用 publish 发布释放锁的消息；存在则用 hincrby 可重入次数 -1，若重入次数大于 0 则刷新续期，否则删除并释放；若不被当前线程持有则返回空 缺点：主从部署或哨兵模式时，master 在加锁后宕机，并且数据未同步到 slave，会导致多客户端同时获取锁 实现 Redis 分布式锁的关键点\n原子性 集群内把锁存起来，使用 SETNX 命令并带上过期时间 过期时间 有效避免死锁 锁续期 另开一个线程，专门用于锁续期，上锁的时候起线程进行死循环续期（比如 3s 的锁，每一段过了第一个 1s 就续 3s） 正确释放锁（不可以提前释放、不可以释放别人的锁） 任务执行完成前不能释放。解锁前要先判断这个 key 的 value 是否是自己加的。value 不能仅仅是线程，分布式可能重复，可以是随机数或机器 IP。即 redis 虽然单线程，但是客户端可能是多线程的。 释放锁时调用 Redis GET 和 DEL 操作是非原子的，所以尽量使用 EVAL (Lua 脚本)，将 GET 和 DEL 包装到一条命令给 Redis 执行 释放锁时先判断锁次数是不是大于 1，是的话就是有锁重入，不能删除，需要减 1，如果次数等于 1 了，也就是没有重入锁了，那就直接删除 WatchDog 实现原理 核心工作流程是定时检测锁是否还存在，还存在的话检查是否快到期，快到期则重新续期，这样防止如果业务代码还没执行完，锁却过期了所带来的的线程不安全问题。。 加锁时开启 WatchDog，删除锁时取消 优缺点 优点\n性能高，对业务系统影响较小 Redisson 客户端类库将所的所有用法都封装了（可重入锁、读写锁、公平锁） 1 2 3 4 # 采用 hash 结构存储 myLock: { [uuid:threadID]:锁次数 } 缺点\n只能保证 AP，对数据一致性要求高的系统不适合（不能真正意义上的一致性地锁住） 分布式 Redis 锁不住？ 先说结论：redis 多机房同步是最终一致的，如果有分布式锁的需求，会有锁不上的情况。redis 锁只能作为弱校验，不能作为强依赖。有强一致锁需求的使用基于 Raft、Paxos 等强一致性（共识算法）的锁更为可靠。\n当 redis 分布式架构的主机房不可用时，系统自动切换到副节点，即 failover 过程。由于主从非同步，在 failover 过程中会导致锁被抢。\nmaster 拿到锁 A slave1-master 同步开启 master 宕机，failover 开启 slave1-master 同步未完成 slave1 被选举为 master，锁 A 丢失，可被抢 使用 RedLock 红锁也锁不住？\nFull GC 恢复后冲突问题 严重依赖时钟系统 效率面前 RedLock 太重 正确性极高场景下 RedLock 不能保证正确性 https://cloud.tencent.com/developer/article/1608807 Zookeeper 实现分布式锁 实现原理 Zookeeper 实现分布式锁的核心原理是临时有序节点，通过判断自己是否是有序节点中序号最小的一个确定是否获得锁，通过删除节点释放锁。ZK 的节点通过 session 心跳来续期。若果客户端 A 创建了一个节点，那么客户端 A 会和 ZK 服务器创建一个 session，通过该 session 的心跳维持连接。如果 ZK 服务器长时间没有收到这个 session 心跳，就认为这个 session 过期了，也会把对应的节点删除。\n对比 Redis 作为分布式锁的时候，为防止宕机死锁需要添加过期时间，为防止提前过期还要开启 WatchDog 续期，ZK 只需要利用临时节点即可。 临时节点类型的最大特性是：当客户端宕机后，临时节点随之消亡。 排他锁（写锁 / 独占锁）\n只允许单事务对指定对象进行读写操作，其他任何事务不能对这个数据对象做任何操作 核心：保证当前有且仅有一个事务获得锁，且锁释放后所有正在等待获取锁的事务都能被通知到 定义锁：通过 ZK 上的临时数据节点来表示一个锁 获取锁：利用 ZK 的同级节点唯一性特点，在需要获取锁时，所有的客户端试图通过调用 create() 在节点下创建临时子节点，最终只有一个客户端能成功，那么此客户端就获得了分布式锁。 阻塞等待：同时，没有获取到锁的客户端阻塞等待，可以在节点上注册一个子节点变更的 watcher 监听事件，以便重新争取获得锁。如果上一个节点释放了锁，那就立即得到通知，然后自己上锁。 释放锁：当客户端抢到锁后就给这个客户端分配一个临时节点，只要没释放就一直持有。当释放主动锁后（正常情况）或服务意外宕机（异常情况）时，临时节点就会被删除，其他客户端就可以重新获取锁。 缺点：并发高容易引起 Zookeeper 的羊群效应（aka 惊群效应 watcher 通知的客户端很多，引起 ZK 性能下降） 解决：客户端只监控比自己小的那个节点，如果自己的序号最小，则获取锁 共享锁（读锁）\n当前事务对指定对象进行读操作，其他事务也只能堆这个数据对象加共享锁，直到该对象上的所有共享锁都被释放 定义锁：通过 ZK 上的临时数据节点来表示一个锁，类似于 /lockpath/[hostname]-请求类型-序号 的临时顺序节点 获取锁：客户端调用 create() 方法创建表示锁的临时顺序节点 读请求：/lockpath/[hostname]-R-序号 写请求：/lockpath/[hostname]-W-序号 判断读写顺序： 创建节点后，获取 /lockpath 节点下所有子节点并注册该节点的子节点变更 watcher 监听 确定自己的节点在所有节点中的顺序 判断 对于读请求：如果没有比自己序号更小的节点，或者序号比自己更小的节点均为读请求，则可认为获得锁，进行读取操作 对于写请求：当且仅当没有比自己序号更小的节点时可进行写操作 接到 watcher 监听事件之后重复上述步骤 释放锁：与排他锁一致（主动删除或宕机被动删除） Zookeeper 锁不住？ Zookeeper 的节点是通过 session 心跳来续期的，比如客户端 A 创建了节点，那么客户端 A 会和 ZK 创建一个 session，通过 session 的心跳来维持连接。 如果 ZK 服务器长时间没收到这个 session 的心跳就认为这个 session 过期了，也会把对应的节点删除。 如果发生了 Full GC，Stop The World 时间大于 session 心跳时间了，就有可能发生误删，或者因为网络抖动导致 session 过期，导致节点被删除，进而其他客户端可以加锁，此时会有两把锁同时执行。\nETCD 实现分布式锁 ETCD 是一个可靠的分布式锁，基于 Raft 算法保持一致性，主要用于共享配置和服务发现\nETCD 基本概念 Lease 机制\n租约机制（TTL），对 KV 设置租约，到期后 KV 失效，客户端可以主动发起续约 Revision 机制\n每个 key 带有一个 revision，ETCD 每执行一次事务对应的全局 revision 值 +1，因此每个 key 对应的 revision 属性都是全局唯一的。通过比较 revision 的大小可以知道进行写操作的顺序，避免惊群效应 Prefix 机制\n可以根据前缀获取该前缀下所有的 key 及对应属性（包括 key，value 及 revision） Watch 机制\n支持 watch 某个固定的 key，也支持 watch 前缀机制，当 watch 的 key 或前缀下发生变化时就会通知客户端 实现原理 ETCD V3 官方实现分布式锁，与 mutex 用法类似。和 Zookeeper 类似，但是实现的机制各有不同。\nSource Code\n1 2 3 4 5 6 // session 基于 lease 机制实现，默认 60s 过期 func NewMutex(s *Session, pfx string) *Mutex // 阻塞直到获取锁，也可以通过 ctx 取消获取锁 func (m *Mutex) Lock(ctx context.Context) error // 解锁 func (m *Mutex) Unlock(ctx context.Context) error 创建租约：假设以 /lock 为前缀，客户端 a 对应的 key 为 /lock/uuid_a，客户端 b 对应的 key 为 /lock/uuid_b，并分别创建租约 客户端写入 key：客户端 a 和 b 分别执行 put 事务操作，得到不同 revision，假设分别为 1 和 2 判断是否得到锁：客户端读取 /lock 前缀下的所有 KV 列表，判断列表中最小的 revision 是否和自己的 revision 相同，如果相同则获取锁 未得到锁监听：未得到锁则监听比自己 revision 小的 key 的删除事件，监听失败则删除自己的 key，防止同一个 session 后序获取锁时出现死锁问题，成功则获取锁。 ","wordCount":"4704","inLanguage":"en","datePublished":"2021-05-15T00:00:00+08:00","dateModified":"2021-05-15T00:00:00+08:00","author":[{"@type":"Person","name":"HyperTars"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.hypertars.com/posts/developer/distributed_systems/lock/"},"publisher":{"@type":"Organization","name":"HyperTars' Blog","logo":{"@type":"ImageObject","url":"https://blog.hypertars.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://blog.hypertars.com accesskey=h title="HyperTars' Blog (Alt + H)">HyperTars' Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://hypertars.com title=🏠Home><span>🏠Home</span></a></li><li><a href=https://blog.hypertars.com/search/ title="🔍Search (Alt + /)" accesskey=/><span>🔍Search</span></a></li><li><a href=https://blog.hypertars.com/posts/developer/ title=👨🏻‍💻Developer><span>👨🏻‍💻Developer</span></a></li><li><a href=https://blog.hypertars.com/archives/ title=⏱Archives><span>⏱Archives</span></a></li><li><a href=https://blog.hypertars.com/tags/ title=🔖tags><span>🔖tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.hypertars.com>Home</a>&nbsp;»&nbsp;<a href=https://blog.hypertars.com/posts/>Articles</a>&nbsp;»&nbsp;<a href=https://blog.hypertars.com/posts/developer/>Developer</a>&nbsp;»&nbsp;<a href=https://blog.hypertars.com/posts/developer/distributed_systems/>Distributed System</a></div><h1 class=post-title>分布式锁</h1><div class=post-description>Distributed Lock</div><div class=post-meta><span title='2021-05-15 00:00:00 +0800 +0800'>2021-05-15</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;HyperTars</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81%e5%b8%b8%e8%a7%81%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af aria-label=分布式锁常见应用场景>分布式锁常见应用场景</a></li><li><a href=#%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81%e7%89%b9%e5%be%81 aria-label=分布式锁特征>分布式锁特征</a></li><li><a href=#%e5%ae%9e%e7%8e%b0%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81%e7%9a%84%e5%b8%b8%e8%a7%81%e6%96%b9%e5%bc%8f aria-label=实现分布式锁的常见方式>实现分布式锁的常见方式</a><ul><li><a href=#mysql-%e5%ae%9e%e7%8e%b0%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81 aria-label="MySQL 实现分布式锁">MySQL 实现分布式锁</a><ul><li><a href=#%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86 aria-label=实现原理>实现原理</a></li><li><a href=#%e4%bc%98%e7%bc%ba%e7%82%b9 aria-label=优缺点>优缺点</a></li></ul></li><li><a href=#redis-%e5%ae%9e%e7%8e%b0%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81 aria-label="Redis 实现分布式锁">Redis 实现分布式锁</a><ul><li><a href=#%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86-1 aria-label=实现原理>实现原理</a></li><li><a href=#%e4%bc%98%e7%bc%ba%e7%82%b9-1 aria-label=优缺点>优缺点</a></li><li><a href=#%e5%88%86%e5%b8%83%e5%bc%8f-redis-%e9%94%81%e4%b8%8d%e4%bd%8f aria-label="分布式 Redis 锁不住？">分布式 Redis 锁不住？</a></li></ul></li><li><a href=#zookeeper-%e5%ae%9e%e7%8e%b0%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81 aria-label="Zookeeper 实现分布式锁">Zookeeper 实现分布式锁</a><ul><li><a href=#%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86-2 aria-label=实现原理>实现原理</a></li><li><a href=#zookeeper-%e9%94%81%e4%b8%8d%e4%bd%8f aria-label="Zookeeper 锁不住？">Zookeeper 锁不住？</a></li></ul></li><li><a href=#etcd-%e5%ae%9e%e7%8e%b0%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81 aria-label="ETCD 实现分布式锁">ETCD 实现分布式锁</a><ul><li><a href=#etcd-%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label="ETCD 基本概念">ETCD 基本概念</a></li><li><a href=#%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86-3 aria-label=实现原理>实现原理</a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener('DOMContentLoaded',function(){checkTocPosition(),elements=document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]'),activeElement=elements[0];const e=encodeURI(activeElement.getAttribute('id')).toLowerCase();document.querySelector(`.inner ul li a[href="#${e}"]`).classList.add('active')},!1),window.addEventListener('resize',function(){checkTocPosition()},!1),window.addEventListener('scroll',()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute('id')).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add('active'):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove('active')})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue('--gap'),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=分布式锁常见应用场景>分布式锁常见应用场景<a hidden class=anchor aria-hidden=true href=#分布式锁常见应用场景>#</a></h2><p><strong>防止缓存击穿</strong></p><ul><li>Redis 的 Key 失效后，在查数据库前加一个分布式锁，查出来后把数据放到 Redis，保证大流量请求进来时，不会出现缓存击穿，只会有一个请求打到数据库。</li></ul><p><strong>保证接口幂等</strong></p><ul><li>表单重复提交后没处理完，再次提交相当于提交了两份。提交后添加分布式锁，第一次提交的时候会锁住，第二次提交发现有锁，就不会继续执行业务逻辑。</li></ul><p><strong>任务调度</strong></p><ul><li>分布式定时任务。可以通过分布式锁保证集群只执行一次任务。</li></ul><h2 id=分布式锁特征>分布式锁特征<a hidden class=anchor aria-hidden=true href=#分布式锁特征>#</a></h2><p>高性能：分布式锁加锁和解锁不影响主业务逻辑，如果每次加锁和解锁都要花费几百 ms 是不能容忍的
可重入：对于同一个线程，要能重复加锁和解锁（可重入的条件是持有锁的线程是当前请求的线程），而不是阻塞等待卡死，重入几次就要释放几次。
互斥性
防死锁：锁不能及时释放会造成死锁，比如加锁了因为服务宕机了没有释放锁，可以给每把锁添加过期时间，这样即时服务意外宕机，等待一段时间后就会自动释放，避免死锁发生。</p><h2 id=实现分布式锁的常见方式>实现分布式锁的常见方式<a hidden class=anchor aria-hidden=true href=#实现分布式锁的常见方式>#</a></h2><h3 id=mysql-实现分布式锁>MySQL 实现分布式锁<a hidden class=anchor aria-hidden=true href=#mysql-实现分布式锁>#</a></h3><h4 id=实现原理>实现原理<a hidden class=anchor aria-hidden=true href=#实现原理>#</a></h4><p>通过 MySQL 唯一索引实现，本质上是对于同一条数据的竞争操作，保证多点系统里同时只有一个执行线程进行处理（只能打到主库）。</p><ul><li>基于唯一索引实现（insert）<ul><li>获取锁时在数据库中 insert 数据，插入成功即视为成功，互斥体现在插入重复数据会报错唯一 key 异常；释放时删除数据</li><li>缺点：强依赖数据库的可用性；没有超时保护，释放失败其他线程无法再次获取；并发压力</li></ul></li><li>基于排它锁实现（for update）<ul><li><code>select .. for update</code> 对查询过程中的数据表增加排它锁，其他线程无法再次增加排它锁，认为获得排它锁的线程获得分布式锁；释放时 <code>commit</code>，提交事务实现</li><li>缺点：强依赖数据库的可用性；排它锁占用连接，产生连接爆满问题，<code>for update</code> 连接阻塞；并发压力</li></ul></li></ul><p><strong>需要考虑的设计细节</strong></p><ul><li>分布式锁的表如何设计？唯一的锁 key 如何设计？可重入如何设计？<ul><li>可重入的关键在于需要一个字段存储重入次数，还要记住是哪个机器、哪个线程重入的<div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SQL data-lang=SQL><span style=display:flex><span><span style=color:#fff;font-weight:700>DROP</span> <span style=color:#fff;font-weight:700>TABLE</span> <span style=color:#fff;font-weight:700>IF</span> <span style=color:#fff;font-weight:700>EXISTS</span> `common_lock`;
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>CREATE</span> <span style=color:#fff;font-weight:700>TABLE</span> `common_lock` (
</span></span><span style=display:flex><span>    `id` uint64 <span style=color:#fff;font-weight:700>NOT</span> <span style=color:#fff;font-weight:700>NULL</span> AUTO_INCREMENT,
</span></span><span style=display:flex><span>    `lock_key` <span style=color:#fff;font-weight:700>varchar</span>(<span style=color:#ff0;font-weight:700>100</span>) <span style=color:#fff;font-weight:700>NOT</span> <span style=color:#fff;font-weight:700>NULL</span>,
</span></span><span style=display:flex><span>    `thread_id` <span style=color:#fff;font-weight:700>int</span> <span style=color:#fff;font-weight:700>NOT</span> <span style=color:#fff;font-weight:700>NULL</span>,
</span></span><span style=display:flex><span>    `entry_count` <span style=color:#fff;font-weight:700>int</span> <span style=color:#fff;font-weight:700>NOT</span> <span style=color:#fff;font-weight:700>NULL</span>,
</span></span><span style=display:flex><span>    `host_ip` <span style=color:#fff;font-weight:700>varchar</span>(<span style=color:#ff0;font-weight:700>30</span>) <span style=color:#fff;font-weight:700>NOT</span> <span style=color:#fff;font-weight:700>NULL</span>,
</span></span><span style=display:flex><span>    `lock_time` <span style=color:#fff;font-weight:700>timestamp</span> <span style=color:#fff;font-weight:700>NOT</span> <span style=color:#fff;font-weight:700>NULL</span>,
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>PRIMARY</span> <span style=color:#fff;font-weight:700>KEY</span> (`id`),
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>UNIQUE</span> <span style=color:#fff;font-weight:700>KEY</span> `lock_key` (`lock_key`) <span style=color:#fff;font-weight:700>USING</span> BTREE
</span></span><span style=display:flex><span>) ENGINE = InnoDB <span style=color:#fff;font-weight:700>DEFAULT</span> CHARSET=utf8mb4;
</span></span></code></pre></td></tr></table></div></div></li></ul></li><li>如何判断重入逻辑？<ul><li>判断有没有锁，有锁再继续判断是不是自己加的锁，如果是自己的锁就更新 <code>entry_count</code> +1</li></ul></li><li>抢锁失败后如何重试？<ul><li>死循环一直重试、重试到一定次数、重试一定时间，若持续加锁失败则退出</li></ul></li><li>如何安全地释放锁？<ul><li>不可以直接删除 key，因为有重入情况。需要先判断重入次数，若大于 1 则减 1，若等于 1 才删除</li></ul></li><li>防死锁设计？加锁成功，释放前系统宕机（需要考虑过期淘汰，防止无限膨胀）<ul><li>起定时任务定时检查由于意外宕机或其他原因导致锁一直没释放的数据，若超过一定时间没释放，则自动释放</li><li>解决方案是记录加锁时间，定时扫描超出 n 秒还未释放的锁的数据，将其删除释放</li><li>删除超过 10 分钟没释放的锁<div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SQL data-lang=SQL><span style=display:flex><span><span style=color:#fff;font-weight:700>SELECT</span> * <span style=color:#fff;font-weight:700>FROM</span> `common_lock` <span style=color:#fff;font-weight:700>WHERE</span> `lock_time` &lt; DATE_SUB(NOW(), <span style=color:#fff;font-weight:700>INTERVAL</span> <span style=color:#ff0;font-weight:700>10</span> <span style=color:#fff;font-weight:700>MINUTE</span>);
</span></span></code></pre></td></tr></table></div></div></li></ul></li><li>follow up：如果流程很耗时，执行结束前定时任务扫描认为锁超时提前释放，其他客户端成功上锁？<ul><li>单独起个线程进行定时续期（WatchDog）</li></ul></li></ul><h4 id=优缺点>优缺点<a hidden class=anchor aria-hidden=true href=#优缺点>#</a></h4><p><strong>优点</strong></p><ul><li>不需要引入其他中间件</li></ul><p><strong>缺点</strong></p><ul><li>性能低、并发低</li><li>强依赖 MySQL，MySQL 不能出现单点故障</li><li>支持的锁种类有限而且使用不灵活，实现非公平锁容易，要实现公平锁需要模拟队列，实现读写锁则更为麻烦</li></ul><h3 id=redis-实现分布式锁>Redis 实现分布式锁<a hidden class=anchor aria-hidden=true href=#redis-实现分布式锁>#</a></h3><h4 id=实现原理-1>实现原理<a hidden class=anchor aria-hidden=true href=#实现原理-1>#</a></h4><ul><li>单节点分布式锁<ul><li>核心是单机单线程，内存速度快。分布式 Redis Cluster 也会有锁不住的问题。主要基于 <code>setnx</code>(SET key ramdom_value NX PX time)，查看是否有响应键值对存在，若没有或过期则设置此键值对，若有则不会获得锁。</li><li>一般用 lua 脚本释放锁，保证原子性；先判断 redis 此时随机值 random_value 是否是之前客户端设置的，如果是则 del，否则不处理。</li><li>随机值：超时后被其他线程抢的锁不可释放</li><li>缺点：主从切换时多客户端认为自己有锁，就锁不住了。</li></ul></li><li>RedLock（redis cluster）<ul><li>核心针对高可用问题，解决单集群 Redis 宕机导致服务不可用以及集群 master 宕机，slave 节点尚未收到同步，导致多 client 获取到锁。</li><li>N 个单独部署的 Redis 集群，每个集群独立存在，无主从复制</li><li>获取锁的操作有一个超时时间，远小于锁的有效时间；向某个 redis 节点获取锁失败后，应立即尝试下一个 redis 节点。</li><li>计算整个获取锁的过程总共消耗了多长时间，如果客户端从大多数 redis 节点成功获取到了锁，并且总耗时没有超过锁的有效时间，那么才认为获取锁成功，否则认为获取锁失败。</li><li>锁的有效时间应当减去获取锁的消耗时间</li><li>如果获取锁失败了，客户端应该立即向所有 redis 节点发起释放锁操作（lua）</li><li>缺点：时钟漂移问题</li></ul></li><li>Redisson（Java 客户端）<ul><li>核心是使用 WatchDog 解决锁续期问题，屏蔽实现细节及实现可重入，等待申请锁资源的进程减少了无效的锁申请，提升资源利用率</li><li>使用 lua 脚本加锁，hash 数据类型的 key 包括当前线程信息、客户端信息，value 用于可重入计数；使用阻塞的方式减少锁的申请</li><li>使用 watchdog 每隔一定时间检查锁是否存在，存在就续期</li><li>使用 lua 脚本解锁，不存在的话用 publish 发布释放锁的消息；存在则用 hincrby 可重入次数 -1，若重入次数大于 0 则刷新续期，否则删除并释放；若不被当前线程持有则返回空</li><li>缺点：主从部署或哨兵模式时，master 在加锁后宕机，并且数据未同步到 slave，会导致多客户端同时获取锁</li></ul></li></ul><p><strong>实现 Redis 分布式锁的关键点</strong></p><ul><li>原子性<ul><li>集群内把锁存起来，使用 SETNX 命令并带上过期时间</li></ul></li><li>过期时间<ul><li>有效避免死锁</li></ul></li><li>锁续期<ul><li>另开一个线程，专门用于锁续期，上锁的时候起线程进行死循环续期（比如 3s 的锁，每一段过了第一个 1s 就续 3s）</li></ul></li><li>正确释放锁（不可以提前释放、不可以释放别人的锁）<ul><li>任务执行完成前不能释放。解锁前要先判断这个 key 的 value 是否是自己加的。value 不能仅仅是线程，分布式可能重复，可以是随机数或机器 IP。即 redis 虽然单线程，但是客户端可能是多线程的。</li><li>释放锁时调用 Redis GET 和 DEL 操作是非原子的，所以尽量使用 EVAL (Lua 脚本)，将 GET 和 DEL 包装到一条命令给 Redis 执行</li><li>释放锁时先判断锁次数是不是大于 1，是的话就是有锁重入，不能删除，需要减 1，如果次数等于 1 了，也就是没有重入锁了，那就直接删除</li></ul></li><li>WatchDog 实现原理<ul><li>核心工作流程是定时检测锁是否还存在，还存在的话检查是否快到期，快到期则重新续期，这样防止如果业务代码还没执行完，锁却过期了所带来的的线程不安全问题。。</li><li>加锁时开启 WatchDog，删除锁时取消</li></ul></li></ul><h4 id=优缺点-1>优缺点<a hidden class=anchor aria-hidden=true href=#优缺点-1>#</a></h4><p><strong>优点</strong></p><ul><li>性能高，对业务系统影响较小</li><li>Redisson 客户端类库将所的所有用法都封装了（可重入锁、读写锁、公平锁）<div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#007f7f># 采用 hash 结构存储</span>
</span></span><span style=display:flex><span>myLock: {
</span></span><span style=display:flex><span>    [uuid:threadID]:锁次数
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div></li></ul><p><strong>缺点</strong></p><ul><li>只能保证 AP，对数据一致性要求高的系统不适合（不能真正意义上的一致性地锁住）</li></ul><h4 id=分布式-redis-锁不住>分布式 Redis 锁不住？<a hidden class=anchor aria-hidden=true href=#分布式-redis-锁不住>#</a></h4><p>先说结论：redis 多机房同步是最终一致的，如果有分布式锁的需求，会有锁不上的情况。redis 锁只能作为弱校验，不能作为强依赖。有强一致锁需求的使用基于 Raft、Paxos 等强一致性（共识算法）的锁更为可靠。</p><p>当 redis 分布式架构的主机房不可用时，系统自动切换到副节点，即 failover 过程。由于主从非同步，在 failover 过程中会导致锁被抢。</p><ol><li>master 拿到锁 A</li><li>slave1-master 同步开启</li><li>master 宕机，failover 开启</li><li>slave1-master 同步未完成</li><li>slave1 被选举为 master，锁 A 丢失，可被抢</li></ol><p>使用 RedLock 红锁也锁不住？</p><ul><li>Full GC 恢复后冲突问题</li><li>严重依赖时钟系统</li><li>效率面前 RedLock 太重</li><li>正确性极高场景下 RedLock 不能保证正确性</li><li><a href=https://cloud.tencent.com/developer/article/1608807>https://cloud.tencent.com/developer/article/1608807</a></li></ul><h3 id=zookeeper-实现分布式锁>Zookeeper 实现分布式锁<a hidden class=anchor aria-hidden=true href=#zookeeper-实现分布式锁>#</a></h3><h4 id=实现原理-2>实现原理<a hidden class=anchor aria-hidden=true href=#实现原理-2>#</a></h4><p>Zookeeper 实现分布式锁的核心原理是临时有序节点，通过判断自己是否是有序节点中序号最小的一个确定是否获得锁，通过删除节点释放锁。ZK 的节点通过 session 心跳来续期。若果客户端 A 创建了一个节点，那么客户端 A 会和 ZK 服务器创建一个 session，通过该 session 的心跳维持连接。如果 ZK 服务器长时间没有收到这个 session 心跳，就认为这个 session 过期了，也会把对应的节点删除。</p><ul><li>对比 Redis 作为分布式锁的时候，为防止宕机死锁需要添加过期时间，为防止提前过期还要开启 WatchDog 续期，ZK 只需要利用临时节点即可。</li><li>临时节点类型的最大特性是：当客户端宕机后，临时节点随之消亡。</li></ul><p><strong>排他锁（写锁 / 独占锁）</strong></p><ul><li>只允许单事务对指定对象进行读写操作，其他任何事务不能对这个数据对象做任何操作</li><li>核心：保证当前有且仅有一个事务获得锁，且锁释放后所有正在等待获取锁的事务都能被通知到</li><li>定义锁：通过 ZK 上的<strong>临时</strong>数据节点来表示一个锁</li><li>获取锁：利用 ZK 的同级节点唯一性特点，在需要获取锁时，所有的客户端试图通过调用 <code>create()</code> 在节点下创建<strong>临时</strong>子节点，最终只有一个客户端能成功，那么此客户端就获得了分布式锁。</li><li>阻塞等待：同时，没有获取到锁的客户端阻塞等待，可以在节点上注册一个子节点变更的 watcher 监听事件，以便重新争取获得锁。如果上一个节点释放了锁，那就立即得到通知，然后自己上锁。</li><li>释放锁：当客户端抢到锁后就给这个客户端分配一个临时节点，只要没释放就一直持有。当释放主动锁后（正常情况）或服务意外宕机（异常情况）时，临时节点就会被删除，其他客户端就可以重新获取锁。</li><li>缺点：并发高容易引起 Zookeeper 的羊群效应（aka 惊群效应 watcher 通知的客户端很多，引起 ZK 性能下降）<ul><li>解决：客户端只监控比自己小的那个节点，如果自己的序号最小，则获取锁</li></ul></li></ul><p><strong>共享锁（读锁）</strong></p><ul><li>当前事务对指定对象进行读操作，其他事务也只能堆这个数据对象加共享锁，直到该对象上的所有共享锁都被释放</li><li>定义锁：通过 ZK 上的<strong>临时</strong>数据节点来表示一个锁，类似于 <code>/lockpath/[hostname]-请求类型-序号</code> 的临时顺序节点</li><li>获取锁：客户端调用 <code>create()</code> 方法创建表示锁的<strong>临时</strong>顺序节点<ul><li>读请求：<code>/lockpath/[hostname]-R-序号</code></li><li>写请求：<code>/lockpath/[hostname]-W-序号</code></li></ul></li><li>判断读写顺序：<ol><li>创建节点后，获取 <code>/lockpath</code> 节点下所有子节点并注册该节点的子节点变更 watcher 监听</li><li>确定自己的节点在所有节点中的顺序</li><li>判断<ul><li>对于读请求：如果没有比自己序号更小的节点，或者序号比自己更小的节点均为读请求，则可认为获得锁，进行读取操作</li><li>对于写请求：当且仅当没有比自己序号更小的节点时可进行写操作</li></ul></li><li>接到 watcher 监听事件之后重复上述步骤</li></ol></li><li>释放锁：与排他锁一致（主动删除或宕机被动删除）</li></ul><h4 id=zookeeper-锁不住>Zookeeper 锁不住？<a hidden class=anchor aria-hidden=true href=#zookeeper-锁不住>#</a></h4><p>Zookeeper 的节点是通过 session 心跳来续期的，比如客户端 A 创建了节点，那么客户端 A 会和 ZK 创建一个 session，通过 session 的心跳来维持连接。
如果 ZK 服务器长时间没收到这个 session 的心跳就认为这个 session 过期了，也会把对应的节点删除。
如果发生了 Full GC，Stop The World 时间大于 session 心跳时间了，就有可能发生误删，或者因为网络抖动导致 session 过期，导致节点被删除，进而其他客户端可以加锁，此时会有两把锁同时执行。</p><h3 id=etcd-实现分布式锁>ETCD 实现分布式锁<a hidden class=anchor aria-hidden=true href=#etcd-实现分布式锁>#</a></h3><p>ETCD 是一个可靠的分布式锁，基于 Raft 算法保持一致性，主要用于共享配置和服务发现</p><h4 id=etcd-基本概念>ETCD 基本概念<a hidden class=anchor aria-hidden=true href=#etcd-基本概念>#</a></h4><p><strong>Lease 机制</strong></p><ul><li>租约机制（TTL），对 KV 设置租约，到期后 KV 失效，客户端可以主动发起续约</li></ul><p><strong>Revision 机制</strong></p><ul><li>每个 key 带有一个 revision，ETCD 每执行一次事务对应的全局 revision 值 +1，因此每个 key 对应的 revision 属性都是全局唯一的。通过比较 revision 的大小可以知道进行写操作的顺序，避免惊群效应</li></ul><p><strong>Prefix 机制</strong></p><ul><li>可以根据前缀获取该前缀下所有的 key 及对应属性（包括 key，value 及 revision）</li></ul><p><strong>Watch 机制</strong></p><ul><li>支持 watch 某个固定的 key，也支持 watch 前缀机制，当 watch 的 key 或前缀下发生变化时就会通知客户端</li></ul><h4 id=实现原理-3>实现原理<a hidden class=anchor aria-hidden=true href=#实现原理-3>#</a></h4><p>ETCD V3 官方实现分布式锁，与 mutex 用法类似。和 Zookeeper 类似，但是实现的机制各有不同。</p><p><a href=https://github.com/etcd-io/etcd/blob/main/client/v3/concurrency/mutex.go>Source Code</a></p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#007f7f>// session 基于 lease 机制实现，默认 60s 过期
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>func</span> NewMutex(s *Session, pfx <span style=color:#fff;font-weight:700>string</span>) *Mutex
</span></span><span style=display:flex><span><span style=color:#007f7f>// 阻塞直到获取锁，也可以通过 ctx 取消获取锁
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>func</span> (m *Mutex) Lock(ctx context.Context) <span style=color:#fff;font-weight:700>error</span>
</span></span><span style=display:flex><span><span style=color:#007f7f>// 解锁
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>func</span> (m *Mutex) Unlock(ctx context.Context) <span style=color:#fff;font-weight:700>error</span>
</span></span></code></pre></td></tr></table></div></div><ol><li>创建租约：假设以 <code>/lock</code> 为前缀，客户端 a 对应的 key 为 <code>/lock/uuid_a</code>，客户端 b 对应的 key 为 <code>/lock/uuid_b</code>，并分别创建租约</li><li>客户端写入 key：客户端 a 和 b 分别执行 put 事务操作，得到不同 revision，假设分别为 1 和 2</li><li>判断是否得到锁：客户端读取 <code>/lock</code> 前缀下的所有 KV 列表，判断列表中最小的 revision 是否和自己的 revision 相同，如果相同则获取锁</li><li>未得到锁监听：未得到锁则监听比自己 revision 小的 key 的删除事件，监听失败则删除自己的 key，防止同一个 session 后序获取锁时出现死锁问题，成功则获取锁。</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.hypertars.com/tags/distributed-system/>Distributed System</a></li><li><a href=https://blog.hypertars.com/tags/distributed-lock/>Distributed Lock</a></li><li><a href=https://blog.hypertars.com/tags/mysql/>MySQL</a></li><li><a href=https://blog.hypertars.com/tags/redis/>Redis</a></li><li><a href=https://blog.hypertars.com/tags/zookeeper/>Zookeeper</a></li></ul><nav class=paginav><a class=prev href=https://blog.hypertars.com/posts/developer/infrastructure/redis/><span class=title>« Prev Page</span><br><span>Redis</span></a>
<a class=next href=https://blog.hypertars.com/posts/developer/database/clickhouse/><span class=title>Next Page »</span><br><span>ClickHouse</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 分布式锁 on twitter" href="https://twitter.com/intent/tweet/?text=%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81&url=https%3a%2f%2fblog.hypertars.com%2fposts%2fdeveloper%2fdistributed_systems%2flock%2f&hashtags=DistributedSystem%2cDistributedLock%2cMySQL%2cRedis%2cZookeeper"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 分布式锁 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fblog.hypertars.com%2fposts%2fdeveloper%2fdistributed_systems%2flock%2f&title=%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81&summary=%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81&source=https%3a%2f%2fblog.hypertars.com%2fposts%2fdeveloper%2fdistributed_systems%2flock%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 分布式锁 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.hypertars.com%2fposts%2fdeveloper%2fdistributed_systems%2flock%2f&title=%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 分布式锁 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.hypertars.com%2fposts%2fdeveloper%2fdistributed_systems%2flock%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 分布式锁 on whatsapp" href="https://api.whatsapp.com/send?text=%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81%20-%20https%3a%2f%2fblog.hypertars.com%2fposts%2fdeveloper%2fdistributed_systems%2flock%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 分布式锁 on telegram" href="https://telegram.me/share/url?text=%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81&url=https%3a%2f%2fblog.hypertars.com%2fposts%2fdeveloper%2fdistributed_systems%2flock%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>