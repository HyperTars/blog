<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>分布式锁 | HyperTars' Blog</title><meta name=keywords content="Distributed System,Distributed Lock"><meta name=description content="Distributed Lock"><meta name=author content="HyperTars"><link rel=canonical href=https://blog.hypertars.com/posts/developer/distributed_systems/lock/><link crossorigin=anonymous href=/assets/css/stylesheet.min.f34b707e96a5011787260c43994ea6cd89c86f5fef677a5e3c78f655715fd662.css integrity="sha256-80twfpalAReHJgxDmU6mzYnIb1/vZ3pePHj2VXFf1mI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.hypertars.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.hypertars.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.hypertars.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.hypertars.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.hypertars.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="分布式锁"><meta property="og:description" content="Distributed Lock"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.hypertars.com/posts/developer/distributed_systems/lock/"><meta property="og:image" content="https://blog.hypertars.com/posts/developer/distributed_systems/lock/https:/raft.github.io/logo/solo.svg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-15T00:00:00+08:00"><meta property="article:modified_time" content="2021-05-15T00:00:00+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.hypertars.com/posts/developer/distributed_systems/lock/https:/raft.github.io/logo/solo.svg"><meta name=twitter:title content="分布式锁"><meta name=twitter:description content="Distributed Lock"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Articles","item":"https://blog.hypertars.com/posts/"},{"@type":"ListItem","position":3,"name":"Developer","item":"https://blog.hypertars.com/posts/developer/"},{"@type":"ListItem","position":4,"name":"Distributed System","item":"https://blog.hypertars.com/posts/developer/distributed_systems/"},{"@type":"ListItem","position":5,"name":"分布式锁","item":"https://blog.hypertars.com/posts/developer/distributed_systems/lock/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"分布式锁","name":"分布式锁","description":"Distributed Lock","keywords":["Distributed System","Distributed Lock"],"articleBody":"分布式锁常见应用场景 防止缓存击穿\n Redis 的 Key 失效后，在查数据库前加一个分布式锁，查出来后把数据放到 Redis，保证大流量请求进来时，不会出现缓存击穿，只会有一个请求打到数据库。  保证接口幂等\n 表单重复提交后没处理完，再次提交相当于提交了两份。提交后添加分布式锁，第一次提交的时候会锁住，第二次提交发现有锁，就不会继续执行业务逻辑。  任务调度\n 分布式定时任务。可以通过分布式锁保证集群只执行一次任务。  分布式锁特征 高性能：分布式锁加锁和解锁不影响主业务逻辑，如果每次加锁和解锁都要花费几百 ms 是不能容忍的 可重入：对于同一个线程，要能重复加锁和解锁（可重入的条件是持有锁的线程是当前请求的线程），而不是阻塞等待卡死，重入几次就要释放几次。 互斥性 防死锁：锁不能及时释放会造成死锁，比如加锁了因为服务宕机了没有释放锁，可以给每把锁添加过期时间，这样即时服务意外宕机，等待一段时间后就会自动释放，避免死锁发生。\n实现分布式锁的常见方式 MySQL 实现分布式锁 实现原理 通过 MySQL 唯一索引实现。只要抢占锁了就插入一条记录，多客户端抢锁会互斥，互斥体现在插入重复数据会报错唯一 key 异常。持有锁的节点执行完逻辑后释放锁，把数据表里的记录删除即可，这样其他节点就可以正常抢锁。\n需要考虑的设计细节\n 分布式锁的表如何设计？唯一的锁 key 如何设计？可重入如何设计？  可重入的关键在于需要一个字段存储重入次数，还要记住是哪个机器、哪个线程重入的 1 2 3 4 5 6 7 8 9 10 11  DROP TABLE IF EXISTS `common_lock`; CREATE TABLE `common_lock` (  `id` uint64 NOT NULL AUTO_INCREMENT,  `lock_key` varchar(100) NOT NULL,  `thread_id` int NOT NULL,  `entry_count` int NOT NULL,  `host_ip` varchar(30) NOT NULL,  `lock_time` timestamp NOT NULL,  PRIMARY KEY (`id`),  UNIQUE KEY `lock_key` (`lock_key`) USING BTREE ) ENGINE = InnoDB DEFAULT CHARSET=utf8mb4;      如何判断重入逻辑？  判断有没有锁，有锁再继续判断是不是自己加的锁，如果是自己的锁就更新 entry_count +1   抢锁失败后如何重试？  死循环一直重试、重试到一定次数、重试一定时间，若持续加锁失败则退出   如何安全地释放锁？  不可以直接删除 key，因为有重入情况。需要先判断重入次数，若大于 1 则减 1，若等于 1 才删除   防死锁设计？加锁成功，释放前系统宕机  起定时任务定时检查由于意外宕机或其他原因导致锁一直没释放的数据，若超过一定时间没释放，则自动释放 解决方案是记录加锁时间，定时扫描超出 n 秒还未释放的锁的数据，将其删除释放 删除超过 10 分钟没释放的锁 1  SELECT * FROM `common_lock` WHERE `lock_time` INTERVAL 10 MINUTE);      follow up：如果流程很耗时，执行结束前定时任务扫描认为锁超时提前释放，其他客户端成功上锁？  单独起个线程进行定时续期（WatchDog）    优缺点 优点\n 不需要引入其他中间件  缺点\n 性能低、并发低 强依赖 MySQL，MySQL 不能出现单点故障 支持的锁种类有限而且使用不灵活，实现非公平锁容易，要实现公平锁需要模拟队列，实现读写锁则更为麻烦  Redis 实现分布式锁 实现原理 Redis 锁的核心是单机单线程，内存速度快。分布式 Redis Cluster 也会有锁不住的问题。 Redis 锁主要基于 setnx(SET key vsalue NX PX time) ，cas（compare and set)， cad(compare and delete) 两个个命令，和 redlock 没有关系。\n实现 Redis 分布式锁的关键点\n 原子性  集群内把锁存起来，使用 SETNX 命令并带上过期时间   过期时间  有效避免死锁   锁续期  另开一个线程，专门用于锁续期，上锁的时候起线程进行死循环续期（比如 3s 的锁，每一段过了第一个 1s 就续 3s）   正确释放锁（不可以提前释放、不可以释放别人的锁）  任务执行完成前不能释放。解锁前要先判断这个 key 的 value 是否是自己加的。value 不能仅仅是线程，分布式可能重复，可以是随机数或机器 IP。即 redis 虽然单线程，但是客户端可能是多线程的。 释放锁时调用 Redis GET 和 DEL 操作是非原子的，所以尽量使用 EVAL (Lua 脚本)，将 GET 和 DEL 包装到一条命令给 Redis 执行 释放锁时先判断锁次数是不是大于 1，是的话就是有锁重入，不能删除，需要减 1，如果次数等于 1 了，也就是没有重入锁了，那就直接删除   WatchDog 实现原理  核心工作流程是定时检测锁是否还存在，还存在的话检查是否快到期，快到期则重新续期，这样防止如果业务代码还没执行完，锁却过期了所带来的的线程不安全问题。。 加锁时开启 WatchDog，删除锁时取消    优缺点 优点\n 性能高，对业务系统影响较小 Redisson 客户端类库将所的所有用法都封装了（可重入锁、读写锁、公平锁） 1 2 3 4  # 采用 hash 结构存储 myLock: {  [uuid:threadID]:锁次数 }     缺点\n 只能保证 AP，对数据一致性要求高的系统不适合（不能真正意义上的一致性地锁住）  Redis 锁不住？ 先说结论：redis 多机房同步是最终一致的，如果有分布式锁的需求，会有锁不上的情况。redis 锁只能作为弱校验，不能作为强依赖。有强一致锁需求的使用基于 Raft、Paxos 等强一致性（共识算法）的锁更为可靠。\n当 redis 分布式架构的主机房不可用时，系统自动切换到副节点，即 failover 过程。由于主从非同步，在 failover 过程中会导致锁被抢。\n master 拿到锁 A slave1-master 同步开启 master 宕机，failover 开启 slave1-master 同步未完成 slave1 被选举为 master，锁 A 丢失，可被抢  使用 RedLock 红锁也锁不住？\n Full GC 恢复后冲突问题 严重依赖时钟系统 效率面前 RedLock 太重 正确性极高场景下 RedLock 不能保证正确性 https://cloud.tencent.com/developer/article/1608807  Zookeeper 实现分布式锁 实现原理 Zookeeper 实现分布式锁的核心原理是临时节点。ZK 的节点通过 session 心跳来续期。若果客户端 A 创建了一个节点，那么客户端 A 会和 ZK 服务器创建一个 session，通过该 session 的心跳维持连接。如果 ZK 服务器长时间没有收到这个 session 心跳，就认为这个 session 过期了，也会把对应的节点删除。\n 对比 Redis 作为分布式锁的时候，为防止宕机死锁需要添加过期时间，为防止提前过期还要开启 WatchDog 续期，ZK 只需要利用临时节点即可。  临时节点类型的最大特性是：当客户端宕机后，临时节点随之消亡。\n临时节点实现\n 利用 ZK 的同级节点唯一性特点，在需要获取锁时，所有的客户端试图通过调用 create() 在节点下创建临时子节点，最终只有一个客户端能成功，那么此客户端就获得了分布式锁。 当客户端抢到锁后就给这个客户端分配一个临时节点，只要没释放就一直持有。当释放锁后或服务意外宕机时，临时节点就会被删除，其他客户端就可以重新获取锁。 同时，没有获取到锁的客户端阻塞等待，可以在节点上注册一个子节点变更的 watcher 监听事件，以便重新争取获得锁。如果上一个节点释放了锁，那就立即得到通知，然后自己上锁。 缺点：并发高容易引起 Zookeeper 的羊群效应（aka 惊群效应 watcher 通知的客户端很多，引起 ZK 性能下降）  解决：客户端只监控比自己小的那个节点，如果自己的序号最小，则获取锁    Zookeeper 锁不住？ Zookeeper 的节点是通过 session 心跳来续期的，比如客户端 A 创建了节点，那么客户端 A 会和 ZK 创建一个 session，通过 session 的心跳来维持连接。 如果 ZK 服务器长时间没收到这个 session 的心跳就认为这个 session 过期了，也会把对应的节点删除。 如果发生了 Full GC，Stop The World 时间大于 session 心跳时间了，就有可能发生误删，或者因为网络抖动导致 session 过期，导致节点被删除，进而其他客户端可以加锁，此时会有两把锁同时执行。\n","wordCount":"2675","inLanguage":"en","image":"https://blog.hypertars.com/posts/developer/distributed_systems/lock/https:/raft.github.io/logo/solo.svg","datePublished":"2021-05-15T00:00:00+08:00","dateModified":"2021-05-15T00:00:00+08:00","author":[{"@type":"Person","name":"HyperTars"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.hypertars.com/posts/developer/distributed_systems/lock/"},"publisher":{"@type":"Organization","name":"HyperTars' Blog","logo":{"@type":"ImageObject","url":"https://blog.hypertars.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.hypertars.com accesskey=h title="HyperTars' Blog (Alt + H)">HyperTars' Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://hypertars.com title=🏠Home><span>🏠Home</span></a></li><li><a href=https://blog.hypertars.com/search/ title="🔍Search (Alt + /)" accesskey=/><span>🔍Search</span></a></li><li><a href=https://blog.hypertars.com/posts/developer/ title=👨🏻‍💻Developer><span>👨🏻‍💻Developer</span></a></li><li><a href=https://blog.hypertars.com/archives/ title=⏱Archives><span>⏱Archives</span></a></li><li><a href=https://blog.hypertars.com/tags/ title=🔖tags><span>🔖tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.hypertars.com>Home</a>&nbsp;»&nbsp;<a href=https://blog.hypertars.com/posts/>Articles</a>&nbsp;»&nbsp;<a href=https://blog.hypertars.com/posts/developer/>Developer</a>&nbsp;»&nbsp;<a href=https://blog.hypertars.com/posts/developer/distributed_systems/>Distributed System</a></div><h1 class=post-title>分布式锁</h1><div class=post-description>Distributed Lock</div><div class=post-meta><span title="2021-05-15 00:00:00 +0800 +0800">2021-05-15</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;HyperTars</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81%e5%b8%b8%e8%a7%81%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af aria-label=分布式锁常见应用场景>分布式锁常见应用场景</a></li><li><a href=#%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81%e7%89%b9%e5%be%81 aria-label=分布式锁特征>分布式锁特征</a></li><li><a href=#%e5%ae%9e%e7%8e%b0%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81%e7%9a%84%e5%b8%b8%e8%a7%81%e6%96%b9%e5%bc%8f aria-label=实现分布式锁的常见方式>实现分布式锁的常见方式</a><ul><li><a href=#mysql-%e5%ae%9e%e7%8e%b0%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81 aria-label="MySQL 实现分布式锁">MySQL 实现分布式锁</a><ul><li><a href=#%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86 aria-label=实现原理>实现原理</a></li><li><a href=#%e4%bc%98%e7%bc%ba%e7%82%b9 aria-label=优缺点>优缺点</a></li></ul></li><li><a href=#redis-%e5%ae%9e%e7%8e%b0%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81 aria-label="Redis 实现分布式锁">Redis 实现分布式锁</a><ul><li><a href=#%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86-1 aria-label=实现原理>实现原理</a></li><li><a href=#%e4%bc%98%e7%bc%ba%e7%82%b9-1 aria-label=优缺点>优缺点</a></li><li><a href=#redis-%e9%94%81%e4%b8%8d%e4%bd%8f aria-label="Redis 锁不住？">Redis 锁不住？</a></li></ul></li><li><a href=#zookeeper-%e5%ae%9e%e7%8e%b0%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81 aria-label="Zookeeper 实现分布式锁">Zookeeper 实现分布式锁</a><ul><li><a href=#%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86-2 aria-label=实现原理>实现原理</a></li><li><a href=#zookeeper-%e9%94%81%e4%b8%8d%e4%bd%8f aria-label="Zookeeper 锁不住？">Zookeeper 锁不住？</a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const e=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${e}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=分布式锁常见应用场景>分布式锁常见应用场景<a hidden class=anchor aria-hidden=true href=#分布式锁常见应用场景>#</a></h2><p><strong>防止缓存击穿</strong></p><ul><li>Redis 的 Key 失效后，在查数据库前加一个分布式锁，查出来后把数据放到 Redis，保证大流量请求进来时，不会出现缓存击穿，只会有一个请求打到数据库。</li></ul><p><strong>保证接口幂等</strong></p><ul><li>表单重复提交后没处理完，再次提交相当于提交了两份。提交后添加分布式锁，第一次提交的时候会锁住，第二次提交发现有锁，就不会继续执行业务逻辑。</li></ul><p><strong>任务调度</strong></p><ul><li>分布式定时任务。可以通过分布式锁保证集群只执行一次任务。</li></ul><h2 id=分布式锁特征>分布式锁特征<a hidden class=anchor aria-hidden=true href=#分布式锁特征>#</a></h2><p>高性能：分布式锁加锁和解锁不影响主业务逻辑，如果每次加锁和解锁都要花费几百 ms 是不能容忍的
可重入：对于同一个线程，要能重复加锁和解锁（可重入的条件是持有锁的线程是当前请求的线程），而不是阻塞等待卡死，重入几次就要释放几次。
互斥性
防死锁：锁不能及时释放会造成死锁，比如加锁了因为服务宕机了没有释放锁，可以给每把锁添加过期时间，这样即时服务意外宕机，等待一段时间后就会自动释放，避免死锁发生。</p><h2 id=实现分布式锁的常见方式>实现分布式锁的常见方式<a hidden class=anchor aria-hidden=true href=#实现分布式锁的常见方式>#</a></h2><h3 id=mysql-实现分布式锁>MySQL 实现分布式锁<a hidden class=anchor aria-hidden=true href=#mysql-实现分布式锁>#</a></h3><h4 id=实现原理>实现原理<a hidden class=anchor aria-hidden=true href=#实现原理>#</a></h4><p>通过 MySQL 唯一索引实现。只要抢占锁了就插入一条记录，多客户端抢锁会互斥，互斥体现在插入重复数据会报错唯一 key 异常。持有锁的节点执行完逻辑后释放锁，把数据表里的记录删除即可，这样其他节点就可以正常抢锁。</p><p><strong>需要考虑的设计细节</strong></p><ul><li>分布式锁的表如何设计？唯一的锁 key 如何设计？可重入如何设计？<ul><li>可重入的关键在于需要一个字段存储重入次数，还要记住是哪个机器、哪个线程重入的<div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SQL data-lang=SQL><span style=display:flex><span><span style=color:#fff;font-weight:700>DROP</span> <span style=color:#fff;font-weight:700>TABLE</span> <span style=color:#fff;font-weight:700>IF</span> <span style=color:#fff;font-weight:700>EXISTS</span> `common_lock`;
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>CREATE</span> <span style=color:#fff;font-weight:700>TABLE</span> `common_lock` (
</span></span><span style=display:flex><span>    `id` uint64 <span style=color:#fff;font-weight:700>NOT</span> <span style=color:#fff;font-weight:700>NULL</span> AUTO_INCREMENT,
</span></span><span style=display:flex><span>    `lock_key` <span style=color:#fff;font-weight:700>varchar</span>(<span style=color:#ff0;font-weight:700>100</span>) <span style=color:#fff;font-weight:700>NOT</span> <span style=color:#fff;font-weight:700>NULL</span>,
</span></span><span style=display:flex><span>    `thread_id` <span style=color:#fff;font-weight:700>int</span> <span style=color:#fff;font-weight:700>NOT</span> <span style=color:#fff;font-weight:700>NULL</span>,
</span></span><span style=display:flex><span>    `entry_count` <span style=color:#fff;font-weight:700>int</span> <span style=color:#fff;font-weight:700>NOT</span> <span style=color:#fff;font-weight:700>NULL</span>,
</span></span><span style=display:flex><span>    `host_ip` <span style=color:#fff;font-weight:700>varchar</span>(<span style=color:#ff0;font-weight:700>30</span>) <span style=color:#fff;font-weight:700>NOT</span> <span style=color:#fff;font-weight:700>NULL</span>,
</span></span><span style=display:flex><span>    `lock_time` <span style=color:#fff;font-weight:700>timestamp</span> <span style=color:#fff;font-weight:700>NOT</span> <span style=color:#fff;font-weight:700>NULL</span>,
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>PRIMARY</span> <span style=color:#fff;font-weight:700>KEY</span> (`id`),
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>UNIQUE</span> <span style=color:#fff;font-weight:700>KEY</span> `lock_key` (`lock_key`) <span style=color:#fff;font-weight:700>USING</span> BTREE
</span></span><span style=display:flex><span>) ENGINE = InnoDB <span style=color:#fff;font-weight:700>DEFAULT</span> CHARSET=utf8mb4;
</span></span></code></pre></td></tr></table></div></div></li></ul></li><li>如何判断重入逻辑？<ul><li>判断有没有锁，有锁再继续判断是不是自己加的锁，如果是自己的锁就更新 <code>entry_count</code> +1</li></ul></li><li>抢锁失败后如何重试？<ul><li>死循环一直重试、重试到一定次数、重试一定时间，若持续加锁失败则退出</li></ul></li><li>如何安全地释放锁？<ul><li>不可以直接删除 key，因为有重入情况。需要先判断重入次数，若大于 1 则减 1，若等于 1 才删除</li></ul></li><li>防死锁设计？加锁成功，释放前系统宕机<ul><li>起定时任务定时检查由于意外宕机或其他原因导致锁一直没释放的数据，若超过一定时间没释放，则自动释放</li><li>解决方案是记录加锁时间，定时扫描超出 n 秒还未释放的锁的数据，将其删除释放</li><li>删除超过 10 分钟没释放的锁<div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SQL data-lang=SQL><span style=display:flex><span><span style=color:#fff;font-weight:700>SELECT</span> * <span style=color:#fff;font-weight:700>FROM</span> `common_lock` <span style=color:#fff;font-weight:700>WHERE</span> `lock_time` &lt; DATE_SUB(NOW(), <span style=color:#fff;font-weight:700>INTERVAL</span> <span style=color:#ff0;font-weight:700>10</span> <span style=color:#fff;font-weight:700>MINUTE</span>);
</span></span></code></pre></td></tr></table></div></div></li></ul></li><li>follow up：如果流程很耗时，执行结束前定时任务扫描认为锁超时提前释放，其他客户端成功上锁？<ul><li>单独起个线程进行定时续期（WatchDog）</li></ul></li></ul><h4 id=优缺点>优缺点<a hidden class=anchor aria-hidden=true href=#优缺点>#</a></h4><p><strong>优点</strong></p><ul><li>不需要引入其他中间件</li></ul><p><strong>缺点</strong></p><ul><li>性能低、并发低</li><li>强依赖 MySQL，MySQL 不能出现单点故障</li><li>支持的锁种类有限而且使用不灵活，实现非公平锁容易，要实现公平锁需要模拟队列，实现读写锁则更为麻烦</li></ul><h3 id=redis-实现分布式锁>Redis 实现分布式锁<a hidden class=anchor aria-hidden=true href=#redis-实现分布式锁>#</a></h3><h4 id=实现原理-1>实现原理<a hidden class=anchor aria-hidden=true href=#实现原理-1>#</a></h4><p>Redis 锁的核心是单机单线程，内存速度快。分布式 Redis Cluster 也会有锁不住的问题。
Redis 锁主要基于 <code>setnx</code>(SET key vsalue NX PX time) ，<code>cas</code>（compare and set)， <code>cad</code>(compare and delete) 两个个命令，和 <code>redlock</code> 没有关系。</p><p><strong>实现 Redis 分布式锁的关键点</strong></p><ul><li>原子性<ul><li>集群内把锁存起来，使用 SETNX 命令并带上过期时间</li></ul></li><li>过期时间<ul><li>有效避免死锁</li></ul></li><li>锁续期<ul><li>另开一个线程，专门用于锁续期，上锁的时候起线程进行死循环续期（比如 3s 的锁，每一段过了第一个 1s 就续 3s）</li></ul></li><li>正确释放锁（不可以提前释放、不可以释放别人的锁）<ul><li>任务执行完成前不能释放。解锁前要先判断这个 key 的 value 是否是自己加的。value 不能仅仅是线程，分布式可能重复，可以是随机数或机器 IP。即 redis 虽然单线程，但是客户端可能是多线程的。</li><li>释放锁时调用 Redis GET 和 DEL 操作是非原子的，所以尽量使用 EVAL (Lua 脚本)，将 GET 和 DEL 包装到一条命令给 Redis 执行</li><li>释放锁时先判断锁次数是不是大于 1，是的话就是有锁重入，不能删除，需要减 1，如果次数等于 1 了，也就是没有重入锁了，那就直接删除</li></ul></li><li>WatchDog 实现原理<ul><li>核心工作流程是定时检测锁是否还存在，还存在的话检查是否快到期，快到期则重新续期，这样防止如果业务代码还没执行完，锁却过期了所带来的的线程不安全问题。。</li><li>加锁时开启 WatchDog，删除锁时取消</li></ul></li></ul><h4 id=优缺点-1>优缺点<a hidden class=anchor aria-hidden=true href=#优缺点-1>#</a></h4><p><strong>优点</strong></p><ul><li>性能高，对业务系统影响较小</li><li>Redisson 客户端类库将所的所有用法都封装了（可重入锁、读写锁、公平锁）<div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#007f7f># 采用 hash 结构存储</span>
</span></span><span style=display:flex><span>myLock: {
</span></span><span style=display:flex><span>    [uuid:threadID]:锁次数
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div></li></ul><p><strong>缺点</strong></p><ul><li>只能保证 AP，对数据一致性要求高的系统不适合（不能真正意义上的一致性地锁住）</li></ul><h4 id=redis-锁不住>Redis 锁不住？<a hidden class=anchor aria-hidden=true href=#redis-锁不住>#</a></h4><p>先说结论：redis 多机房同步是最终一致的，如果有分布式锁的需求，会有锁不上的情况。redis 锁只能作为弱校验，不能作为强依赖。有强一致锁需求的使用基于 Raft、Paxos 等强一致性（共识算法）的锁更为可靠。</p><p>当 redis 分布式架构的主机房不可用时，系统自动切换到副节点，即 failover 过程。由于主从非同步，在 failover 过程中会导致锁被抢。</p><ol><li>master 拿到锁 A</li><li>slave1-master 同步开启</li><li>master 宕机，failover 开启</li><li>slave1-master 同步未完成</li><li>slave1 被选举为 master，锁 A 丢失，可被抢</li></ol><p>使用 RedLock 红锁也锁不住？</p><ul><li>Full GC 恢复后冲突问题</li><li>严重依赖时钟系统</li><li>效率面前 RedLock 太重</li><li>正确性极高场景下 RedLock 不能保证正确性</li><li><a href=https://cloud.tencent.com/developer/article/1608807>https://cloud.tencent.com/developer/article/1608807</a></li></ul><h3 id=zookeeper-实现分布式锁>Zookeeper 实现分布式锁<a hidden class=anchor aria-hidden=true href=#zookeeper-实现分布式锁>#</a></h3><h4 id=实现原理-2>实现原理<a hidden class=anchor aria-hidden=true href=#实现原理-2>#</a></h4><p>Zookeeper 实现分布式锁的核心原理是临时节点。ZK 的节点通过 session 心跳来续期。若果客户端 A 创建了一个节点，那么客户端 A 会和 ZK 服务器创建一个 session，通过该 session 的心跳维持连接。如果 ZK 服务器长时间没有收到这个 session 心跳，就认为这个 session 过期了，也会把对应的节点删除。</p><ul><li>对比 Redis 作为分布式锁的时候，为防止宕机死锁需要添加过期时间，为防止提前过期还要开启 WatchDog 续期，ZK 只需要利用临时节点即可。</li></ul><p>临时节点类型的最大特性是：当客户端宕机后，临时节点随之消亡。</p><p>临时节点实现</p><ul><li>利用 ZK 的同级节点唯一性特点，在需要获取锁时，所有的客户端试图通过调用 create() 在节点下创建临时子节点，最终只有一个客户端能成功，那么此客户端就获得了分布式锁。</li><li>当客户端抢到锁后就给这个客户端分配一个临时节点，只要没释放就一直持有。当释放锁后或服务意外宕机时，临时节点就会被删除，其他客户端就可以重新获取锁。</li><li>同时，没有获取到锁的客户端阻塞等待，可以在节点上注册一个子节点变更的 watcher 监听事件，以便重新争取获得锁。如果上一个节点释放了锁，那就立即得到通知，然后自己上锁。</li><li>缺点：并发高容易引起 Zookeeper 的羊群效应（aka 惊群效应 watcher 通知的客户端很多，引起 ZK 性能下降）<ul><li>解决：客户端只监控比自己小的那个节点，如果自己的序号最小，则获取锁</li></ul></li></ul><h4 id=zookeeper-锁不住>Zookeeper 锁不住？<a hidden class=anchor aria-hidden=true href=#zookeeper-锁不住>#</a></h4><p>Zookeeper 的节点是通过 session 心跳来续期的，比如客户端 A 创建了节点，那么客户端 A 会和 ZK 创建一个 session，通过 session 的心跳来维持连接。
如果 ZK 服务器长时间没收到这个 session 的心跳就认为这个 session 过期了，也会把对应的节点删除。
如果发生了 Full GC，Stop The World 时间大于 session 心跳时间了，就有可能发生误删，或者因为网络抖动导致 session 过期，导致节点被删除，进而其他客户端可以加锁，此时会有两把锁同时执行。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.hypertars.com/tags/distributed-system/>Distributed System</a></li><li><a href=https://blog.hypertars.com/tags/distributed-lock/>Distributed Lock</a></li></ul><nav class=paginav><a class=next href=https://blog.hypertars.com/posts/developer/database/clickhouse/><span class=title>Next Page »</span><br><span>ClickHouse</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 分布式锁 on twitter" href="https://twitter.com/intent/tweet/?text=%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81&url=https%3a%2f%2fblog.hypertars.com%2fposts%2fdeveloper%2fdistributed_systems%2flock%2f&hashtags=DistributedSystem%2cDistributedLock"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 分布式锁 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fblog.hypertars.com%2fposts%2fdeveloper%2fdistributed_systems%2flock%2f&title=%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81&summary=%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81&source=https%3a%2f%2fblog.hypertars.com%2fposts%2fdeveloper%2fdistributed_systems%2flock%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 分布式锁 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.hypertars.com%2fposts%2fdeveloper%2fdistributed_systems%2flock%2f&title=%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 分布式锁 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.hypertars.com%2fposts%2fdeveloper%2fdistributed_systems%2flock%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 分布式锁 on whatsapp" href="https://api.whatsapp.com/send?text=%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81%20-%20https%3a%2f%2fblog.hypertars.com%2fposts%2fdeveloper%2fdistributed_systems%2flock%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 分布式锁 on telegram" href="https://telegram.me/share/url?text=%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81&url=https%3a%2f%2fblog.hypertars.com%2fposts%2fdeveloper%2fdistributed_systems%2flock%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>