<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>分布式事务 | HyperTars' Blog</title><meta name=keywords content="Distributed System,Distributed Transaction,CAP,BASE,XA,TCC,SAGA"><meta name=description content="Introduction to distributed transactions"><meta name=author content="HyperTars"><link rel=canonical href=https://blog.hypertars.com/posts/developer/distributed_systems/transaction/><link crossorigin=anonymous href=/assets/css/stylesheet.min.f34b707e96a5011787260c43994ea6cd89c86f5fef677a5e3c78f655715fd662.css integrity="sha256-80twfpalAReHJgxDmU6mzYnIb1/vZ3pePHj2VXFf1mI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.hypertars.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.hypertars.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.hypertars.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.hypertars.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.hypertars.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="分布式事务"><meta property="og:description" content="Introduction to distributed transactions"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.hypertars.com/posts/developer/distributed_systems/transaction/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-02T10:41:32+08:00"><meta property="article:modified_time" content="2022-05-02T22:01:28+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="分布式事务"><meta name=twitter:description content="Introduction to distributed transactions"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Articles","item":"https://blog.hypertars.com/posts/"},{"@type":"ListItem","position":3,"name":"Developer","item":"https://blog.hypertars.com/posts/developer/"},{"@type":"ListItem","position":4,"name":"Distributed System","item":"https://blog.hypertars.com/posts/developer/distributed_systems/"},{"@type":"ListItem","position":5,"name":"分布式事务","item":"https://blog.hypertars.com/posts/developer/distributed_systems/transaction/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"分布式事务","name":"分布式事务","description":"Introduction to distributed transactions","keywords":["Distributed System","Distributed Transaction","CAP","BASE","XA","TCC","SAGA"],"articleBody":"1. 事务与分布式事务 1.1 事务 事务是数据库管理系统执行过程中的一个逻辑单元，能够保证一个事务中所有操作要么全部执行，要么全不执行。\n数据库事务拥有四个特性 ACID，分别为 Atomicity 原子性、Consistency 一致性、Isolation 隔离性、Durability 持久性。\n1.2 分布式事务 分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点上。一个流程操作不取决于本地的数据库操作。分布式事务就是为了保证不同数据库的一致性。\n分布式事务之所以复杂，一个主要原因是同一个事务之间的执行多段代码会因为网络的不稳定造成失败等问题。当通过网络请求其他服务的接口时，可能得到 正确、失败、超时 三种结果。无论成功或失败都能得到唯一确定的结果，但是超时却不能确定接收者是否成功处理了请求，而这也成为造成诸多问题的诱因。系统之间的通信可靠性从单一系统中的可靠变成了微服务结构之间的不可靠，分布式事务其实就是在不可靠的通信下实现事务的特性。\n1.3 分布式事务基础：一致性   强一致性\n 任何一次都能读到某个数据的最近一次写数据。系统中的所有进程，看到的操作顺序，都和全局时钟下的顺序一致。任意时刻，所有节点中的数据都是一样的。    弱一致性\n 数据更新后，如果能容忍后序的访问只能访问到部分或者全部访问不到，则是弱一致性。    最终一致性\n 不保证在任意时刻任意节点上的同一份数据都相同的，但是随着时间的推移，不同节点上的同一份数据总是在向趋同的方向变化。一段时间后，节点间的数据会最终达到一致状态。    1.4 分布式事务基础：CAP 原则 CAP 原则又称为 CAP 定理，指在一个分布式系统中，Consistency 一致性、Availability 可用性、Partition-tolerance 分区容错性 三者不可兼得。\n Consistency 一致性：在分布式系统中的所有数据备份，在同一时刻是否同样的值（等同于所有节点访问同一份最新的数据副本） Availability 可用性：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求（对数据更新具备高可用性） Partition-tolerance 分区容错性：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。  CAP 三者取舍\n CA：优先保证一致性和可用性，放弃系统扩展性，系统不再是分布式 CP：优先保证一致性和分区容错性，在一致性要求较高的场合比较常见 Zookeeper，HBase；一旦发生网络故障或消息丢失，会牺牲用户体验，恢复后才逐渐能访问 AP：优先保证可用性和分区容错性，如 RocketMQ 的 那么server，SpringCloud 的 Eureka  分布式事务会部分遵循 ACID 规范\n 原子性：严格遵循 一致性：事务完成后的一致性严格遵循；事务中的一致性可适当放宽 隔离性：并行事务间不可影响；事务中间结果可见性允许安全放宽 持久性：严格遵循  因为事务过程中，不是一致的，但事务会最终完成，最终达到一致，所以我们把分布式事务称为“最终一致”\n1.5 分布式事务基础：BASE 理论 BASE aka Basically Availability Soft State Eventual Consistency\n Basically Availability 基本可用：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用 Soft State 软状态：允许系统存在中间状态，而该中间状态不会影响系统整体可用性 Eventual Consistency 最终一致性：系统中的所有数据副本经过一定时间后，最终能够达到一致的状态  BASE 理论本质上是对 CAP 理论的延伸，是对 AP 方案的一个补充\n1.6 CP + HA 分布式事务是在分布式环境下，遵循CAP理论，在CAP三者中只能够三选二，那么分布式事务是那种的组合呢？分布式事务是CP+HA，其中A是没有完全符合，但是能够达到Highly-Available，即高可用。\n近些年分布式理论进一步发展，产生了Paxos、Raft等CP的协议，在这基础上，加上硬件稳定性升级，可以在保证CP的情况下，做到高可用。谷歌分布式锁Chubby的公开数据显示，集群能提供99.99958％的平均可用性，一年也就130s的运行中断，已经能够满足非常严苛的应用要求。现在的SQL类数据库软件，都是走CP+HA，只是HA会比谷歌的这个极致数据更低一些，但一般都能够达到4个9\nCP+HA意味着不是BASE，意味着你只要写入成功，那么接下来的读，能够读取到最新的结果，开发人员不用担心读取到的不是最新数据，在多副本读写上面，与单机是一致的。\n2. 分布式事务解决方案 2.1 XA (2PC) XA 规范是 X/Open 组织定义的分布式事务处理 Distributed Transaction Processing 标准。XA 事务由一个或多个资源管理器（RM）、一个事务管理器（TM）和一个应用程序（ApplicationProgram）组成。\nXA 规范描述了全局的事务管理器与局部的资源管理器之间的接口。XA 规范的目的是允许的多个资源（数据库、应用服务器、消息队列等）在同一事务中访问，这样可以使 ACID 属性跨越应用程序而保持有效。XA 规范主要定义了(全局)事务管理器(TM)和(局部)资源管理器(RM)之间的接口。本地的数据库如 mysql 在 XA 中扮演的是 RM 角色。\nXA 规范使用两阶段提交（2PC Two-Phase Commit）来保证所有资源同时提交或回滚任何特定的事务。\nXA 流程\n 阶段一 Prepare：事务管理器向所有本地资源管理器发送请求，询问是否处于 ready 状态，所有参与者都将本事务是否成功的信息反馈发给协调者。即所有的参与者 RM 准备执行事务并锁住需要的资源。参与者 ready 时，向 TM 报告已准备就绪。 阶段二 Commit / Rollback：当事务管理者(TM)确认所有参与者(RM)都ready后，向所有参与者发送commit命令。事务管理器根据所有本地资源管理器的反馈，通知所有本地资源管理器，步调一致地在所有分支上提交或者回滚。  目前主流的数据库基本都支持XA事务，包括mysql、oracle、sqlserver、postgre。\n优点\n 对业务侵⼊很小，它最⼤的优势就是对使⽤⽅透明，用户可以像使⽤本地事务⼀样使⽤基于 XA 协议的分布式事务，能够严格保障事务 ACID 特性。  缺点\n 同步阻塞：当参与事务者存在占用公共资源的情况，其中一个占用了资源，其他事务参与者就只能阻塞等待资源释放，处于阻塞状态。对资源进行了长时间的锁定，并发度低。 单点故障：一旦事务管理器出现故障，整个系统不可用 数据不一致：在阶段二，如果事务管理器只发送了部分 commit 消息，此时网络发生异常，那么只有部分参与者接收到 commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。 不确定性：当协事务管理器发送 commit 之后，并且此时只有一个参与者收到了 commit，那么当该参与者与事务管理器同时宕机之后，重新选举的事务管理器无法确定该条消息是否提交成功。 XA要求数据库本身提供对规范和协议的支持  2.2 AT AT 对业务代码完全无侵入性，使用非常简单，改造成本低。我们只需要关注自己的业务SQL，AT模式下框架会通过分析我们业务SQL，反向生成回滚数据。\nAT 包含两个阶段\n 一阶段，所有参与事务的分支，本地事务Commit 业务数据和回滚日志（undoLog） 二阶段，事务协调者根据所有分支的情况，决定本次全局事务是Commit 还是 Rollback（二阶段是完全异步）  核心流程\n 为每个事务参与者的数据库创建一个 undo log 表，用于记录 DML SQL 执行前的行记录 每个事务参与者实际执行 DML SQL 时，生成修改前数据插入到 undo log 表中  流程图\n拓扑图\n优点\n 该事务模式使用方式，类似XA模式，业务无需编写各类补偿操作，回滚由框架自动完成  缺点\n 也类似XA，存在较长时间的锁，不满足高并发的场景。从性能的角度看，AT模式会比XA更高一些，但也带来了脏回滚这样的新问题。  2.3 TCC TCC 完整语义 Try-Confirm-Cancel\n Try：尝试执行，完成所有业务检查（一致性），预留必须业务资源（准隔离性），如加锁，加标记字段。TCC事务机制中的业务逻辑（Try），从执行阶段来看，与传统事务机制中业务逻辑相同。但从业务角度来看，却不一样。TCC机制中的Try仅是一个初步操作，它和后续的确认一起才能真正构成一个完整的业务逻辑。TCC机制将传统事务机制中的业务逻辑一分为二，拆分后保留的部分即为初步操作（Try）；而分离出的部分即为确认操作（Confirm），被延迟到事务提交阶段执行。TCC事务机制以初步操作（Try）为中心的，确认操作（Confirm）和取消操作（Cancel）都是围绕初步操作（Try）而展开。因此，Try阶段中的操作，其保障性是最好的，即使失败，仍然有取消操作（Cancel）可以将其不良影响进行回撤。可以认为  1  [传统事务机制]的业务逻辑 = [TCC事务机制]的初步操作（Try） + [TCC事务机制]的确认逻辑（Confirm）。    Confirm：真正确认执行业务，不做任务业务检查，只用 Try 阶段预留的业务资源；操作必须满足幂等性，失败后需要进行重试。确认操作（Confirm）是对初步操作（Try）的一个补充。当TCC事务管理器决定commit全局事务时，就会逐个执行初步操作（Try）指定的确认操作（Confirm），将初步操作（Try）未完成的事项最终完成。 Cancel：取消执行，释放 Try 阶段预留的业务资源；操作必须满足幂等性，异常处理和 Confirm 一致。取消操作（Cancel）是对初步操作（Try）的一个回撤。当TCC事务管理器决定rollback全局事务时，就会逐个执行初步操作（Try）指定的取消操作（Cancel），将初步操作（Try）已完成的事项全部撤回。  在 Try 阶段，对业务系统进行检查及资源预览，比如订单和存储操作，需要检查库存剩余数量是否够用，并进行预留，预留操作的话就是新建一个可用库存数量字段，Try 阶段操作是对这个可用库存数量进行操作。\n基于 TCC 实现分布式事务，会将原来只需要一个接口就可以实现的逻辑拆分为 Try、Confirm、Cancel 三个接口，所以代码实现复杂度相对较高，对业务的侵入性大。\nTCC的Confirm/Cancel阶段在业务逻辑上是不允许返回失败的，如果因为网络或者其他临时故障，导致不能返回成功，TM会不断的重试，直到Confirm/Cancel返回成功。\nTCC特点如下\n 并发度较高，无长期资源锁定。 开发量较大，需要提供Try/Confirm/Cancel接口。 一致性较好，不会发生SAGA已扣款最后又转账失败的情况 TCC适用于订单类业务，对中间状态有约束的业务  TCC 和 2PC？ TCC 并不是 2PC 的一种。2PC 需要 RM 提供底层支持（一般是兼容 XA），而 TCC 不需要。对于传统事务机制 X/Open XA 2PC，其特征在于它不依赖资源管理器 Resource Manager 对 XA 的支持，而是通过对（由业务系统提供的）业务逻辑的调度来实现分布式事务。\n对于业务系统中一个特定的业务逻辑S，其对外提供服务时，必须接受一些不确定性，即对业务逻辑执行的一次调用仅是一个临时性操作，调用它的消费方服务M保留了后续的取消权。如果M认为全局事务应该rollback，它会要求取消之前的临时性操作，这将对应S的一个取消操作；而当M认为全局事务应该commit时，它会放弃之前临时性操作的取消权，这对应S的一个确认操作。\n每一个初步操作，最终都会被确认或取消。因此，针对一个具体的业务服务，TCC事务机制需要业务系统提供三段业务逻辑：初步操作Try、确认操作Confirm、取消操作Cancel。\nTCC 在事务处理上，要么调用 confirm，要么调用 cancel；try 逻辑与全局事务无关。 使用 2PC 时完整的事务生命周期是：begin - 业务逻辑 - prepare - commit 使用 TCC 时完整的事务生命周期是：begin - 业务逻辑 (try) - commit (confirm 业务)\n在执行阶段可以将二者一一对应\n 2PC 业务阶段 - TCC try 业务阶段 2PC 提交阶段 (prepare \u0026 commit) - TCC confirm 提交阶段 2PC 回滚阶段 (rollback) - TCC cancel 回滚阶段  TCC 不是 2PC，只是它对事务的 提交/回滚 是通过执行一段 confirm/cancel 业务逻辑来实现而已。\nTCC 事务管理器协调者设计 TCC全局事务必须基于 RM 本地事务来实现全局事务\n Try/Confirm/Cancel业务在执行时，会访问资源管理器（Resource Manager，下文简称RM）来存取数据。这些存取操作，必须要参与RM本地事务，以使其更改的数据要么都commit，要么都rollback。 分布式事务管理框架的职责，不是做出全局事务提交/回滚的指令，而是管理全局事务提交/回滚的过程。  实际实现中：\n 只实现 try cancel 就是一个 SAGA  一般扣除类动作，try 时即扣除，cancel 时补偿，confirm 为空；因为 confirm 时再完成扣除可能已经余额不足，因此要求 confirm 一定成功。 但是发放类动作，一般不适用 SAGA，因为 cancel 前可能已经被消耗，导致无法回滚，此时必须用 TCC 语义在 confirm 时是肌肤放。   只实现 try confirm 就是一个 XA  TCC 语义与问题解决 子事务接口约束\n 中间态设计：try 成功后，confirm / cancel 必须成功 try / confirm / cancel 幂等 cancel 允许空回滚 cancel 允许请求倒挂（try 悬挂）  问题：Try 超时（空回滚）\n Cancel 接口设计时允许空回滚。在 try 接口因为丢包没有收到时，事务管理器会触发回滚，这时会出发 Cancel 接口，若发现没有对应事务的 xid 或主键时，需要返回回滚成功。让事务服务管理器认为已回滚，否则会不断重试。  问题：Confirm / Cancel 超时\n 因为网络抖动或拥堵可能超时，事务管理器会对资源进行重试操作，为了不因为重复调用而多次占用资源，设计时进行幂等控制。  问题：Try 比 Cancel 晚到达（try 悬挂）\n Cancel 比 try 先执行，事务管理器生成回滚，而之后收到了 try 接口调用。此时 try 接口因 cancel 已执行而不再执行，否则产生数据不一致。所以在 try 前先检查该事务 xid 或业务主键，如果已经标记为回滚成功过，就不再执行 try 的业务操作。  2.4 SAGA SAGA事务，其核心思想是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。每个参与者都定义一个正向行为（变更）和一个反向行为（补偿），分布式事务按照既定顺序执行正向行为直到全部成功（提交），如果中间发生错误，则逆序执行对应的反向行为（回滚）。\nSAGA 执行流程如下\n 分支事务 1 到 N 依次执行成功，全局事务成功 分支事务 i 执行失败，从分支事务 i 倒序至分支事务 1，依次执行补偿，失败则重试，补偿需幂等（回滚优先策略） 分支事务 i 执行失败，重试直到成功，然后依次执行后序分支事务，正向操作保障幂等（重试优先策略）  适用场景\n 业务流程长、业务流程多 长事务适用，对中间结果不敏感的业务场景适用 参与者包含其它公司或遗留系统服务，无法提供 TCC 模式要求的三个接口  优势\n 并发度高，不用像XA事务那样长期锁定资源 一阶段提交本地事务，无锁，高性能 事件驱动架构，参与者可异步执行，高吞吐 需要定义正常操作以及补偿操作，开发量比XA大，但是补偿服务易于实现 相较于 TCC 业务侵入度适中  缺点\n 不保证隔离性 一致性较弱，对于转账，可能发生A用户已扣款，最后转账又失败的情况  2.5 本地消息表 本地消息表方案中会有消息生产者与消费者两个角色，假设服务 A 是消息的生产者，服务 B 是消息的消费者。写本地消息和业务操作放在一个事务里，保证了业务和发消息的原子性，要么他们全都成功，要么全都失败。此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。\n 当服务 A 被其他服务调用发生数据库表更操作，首先会更新该服务数据库的业务表，其次会往相同数据库的消息表中插入一条数据，两个操作发生在同一个事务中 服务 A 的脚本定期轮询本地消息往 mq 中写入一条消息，如果消息发送失败会进行重试 服务 B 消费 mq 中的消息，并处理业务逻辑。如果本地事务处理失败，会在继续消费 mq 中的消息进行重试，如果业务上的失败，可以通知服务 A 进行回滚操作，或进行告警通知相关人员进行处理。  本地消息表的实现条件\n 消费者与生成者的接口都要幂等 生产者需要额外的创建消息记录表 可能需要提供补偿逻辑，如果消费者业务失败，生产者可支持回滚操作 进行重试或进行业务逻辑告警，通过人工介入的方式处理。  适用场景\n 可异步执行的业务，且后续操作无需回滚的业务  容错机制\n 扣减余额事务 失败时，事务直接回滚，无后续步骤 轮序生产消息失败， 增加余额事务失败都会进行重试  本地消息表的特点\n 不支持回滚 轮询生产消息难实现，如果定时轮询会延长事务总时长，如果订阅binlog则开发维护困难 适用于可异步执行的业务，且后续操作无需回滚的业务  2.6 事务消息 在上述的本地消息表方案中，生产者需要额外创建消息表，还需要对本地消息表进行轮询，业务负担较重。阿里开源的RocketMQ 4.3之后的版本正式支持事务消息，该事务消息本质上是把本地消息表放到RocketMQ上，解决生产端的消息发送与本地事务执行的原子性问题。\n事务消息发送及提交\n 发送消息（half消息） 服务端存储消息，并响应消息的写入结果 根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行） 根据本地事务状态执行Commit或者Rollback（Commit操作发布消息，消息对消费者可见）  补偿流程\n 对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查” Producer收到回查消息，返回消息对应的本地事务的状态，为Commit或者Rollback 事务消息方案与本地消息表机制非常类似，区别主要在于原先相关的本地表操作替换成了一个反查接口  事务消息特点\n 长事务仅需要分拆成多个任务，并提供一个反查接口，使用简单 事务消息的回查没有好的方案，极端情况可能出现数据错误 适用于可异步执行的业务，且后续操作无需回滚的业务  适用场景\n 可异步执行的业务，且后续操作无需回滚的业务  2.7 最大努力通知 发起通知方通过一定的机制最大努力将业务处理结果通知到接收方。具体包括：\n 有一定的消息重复通知机制。因为接收通知方可能没有接收到通知，此时要有一定的机制对消息重复通知。 消息校对机制。如果尽最大努力也没有通知到接收方，或者接收方消费消息后要再次消费，此时可由接收方主动向通知方查询消息信息来满足需求。  前面的本地消息表和事务消息都属于可靠消息，与这里的最大努力通知有什么不同？\n 可靠消息一致性，发起通知方需要保证将消息发出去，并且将消息发到接收通知方，消息的可靠性关键由发起通知方来保证。 最大努力通知，发起通知方尽最大的努力将业务处理结果通知为接收通知方，但是可能消息接收不到，此时需要接收通知方主动调用发起通知方的接口查询业务处理结果，通知的可靠性关键在接收通知方。  解决方案上，最大努力通知需要：\n 提供接口，让接受通知放能够通过接口查询业务处理结果 消息队列ACK机制，消息队列按照间隔1min、5min、10min、30min、1h、2h、5h、10h的方式，逐步拉大通知间隔 ，直到达到通知要求的时间窗口上限。之后不再通知  适用类型\n 业务通知类型，例如微信交易的结果，就是通过最大努力通知方式通知各个商户，既有回调通知，也有交易查询接口  ","wordCount":"7550","inLanguage":"en","datePublished":"2021-05-02T10:41:32+08:00","dateModified":"2022-05-02T22:01:28+08:00","author":[{"@type":"Person","name":"HyperTars"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.hypertars.com/posts/developer/distributed_systems/transaction/"},"publisher":{"@type":"Organization","name":"HyperTars' Blog","logo":{"@type":"ImageObject","url":"https://blog.hypertars.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.hypertars.com accesskey=h title="HyperTars' Blog (Alt + H)">HyperTars' Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://hypertars.com title=🏠Home><span>🏠Home</span></a></li><li><a href=https://blog.hypertars.com/search/ title="🔍Search (Alt + /)" accesskey=/><span>🔍Search</span></a></li><li><a href=https://blog.hypertars.com/posts/developer/ title=👨🏻‍💻Developer><span>👨🏻‍💻Developer</span></a></li><li><a href=https://blog.hypertars.com/archives/ title=⏱Archives><span>⏱Archives</span></a></li><li><a href=https://blog.hypertars.com/tags/ title=🔖tags><span>🔖tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.hypertars.com>Home</a>&nbsp;»&nbsp;<a href=https://blog.hypertars.com/posts/>Articles</a>&nbsp;»&nbsp;<a href=https://blog.hypertars.com/posts/developer/>Developer</a>&nbsp;»&nbsp;<a href=https://blog.hypertars.com/posts/developer/distributed_systems/>Distributed System</a></div><h1 class=post-title>分布式事务</h1><div class=post-description>Introduction to distributed transactions</div><div class=post-meta><span title="2021-05-02 10:41:32 +0800 +0800">2021-05-02</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;HyperTars</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-%e4%ba%8b%e5%8a%a1%e4%b8%8e%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1 aria-label="1. 事务与分布式事务">1. 事务与分布式事务</a><ul><li><a href=#11-%e4%ba%8b%e5%8a%a1 aria-label="1.1 事务">1.1 事务</a></li><li><a href=#12-%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1 aria-label="1.2 分布式事务">1.2 分布式事务</a></li><li><a href=#13-%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1%e5%9f%ba%e7%a1%80%e4%b8%80%e8%87%b4%e6%80%a7 aria-label="1.3 分布式事务基础：一致性">1.3 分布式事务基础：一致性</a></li><li><a href=#14-%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1%e5%9f%ba%e7%a1%80cap-%e5%8e%9f%e5%88%99 aria-label="1.4 分布式事务基础：CAP 原则">1.4 分布式事务基础：CAP 原则</a></li><li><a href=#15-%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1%e5%9f%ba%e7%a1%80base-%e7%90%86%e8%ae%ba aria-label="1.5 分布式事务基础：BASE 理论">1.5 分布式事务基础：BASE 理论</a></li><li><a href=#16-cp--ha aria-label="1.6 CP + HA">1.6 CP + HA</a></li></ul></li><li><a href=#2-%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88 aria-label="2. 分布式事务解决方案">2. 分布式事务解决方案</a><ul><li><a href=#21-xa-2pc aria-label="2.1 XA (2PC)">2.1 XA (2PC)</a></li><li><a href=#22-at aria-label="2.2 AT">2.2 AT</a></li><li><a href=#23-tcc aria-label="2.3 TCC">2.3 TCC</a><ul><li><a href=#tcc-%e5%92%8c-2pc aria-label="TCC 和 2PC？">TCC 和 2PC？</a></li><li><a href=#tcc-%e4%ba%8b%e5%8a%a1%e7%ae%a1%e7%90%86%e5%99%a8%e5%8d%8f%e8%b0%83%e8%80%85%e8%ae%be%e8%ae%a1 aria-label="TCC 事务管理器协调者设计">TCC 事务管理器协调者设计</a></li><li><a href=#tcc-%e8%af%ad%e4%b9%89%e4%b8%8e%e9%97%ae%e9%a2%98%e8%a7%a3%e5%86%b3 aria-label="TCC 语义与问题解决">TCC 语义与问题解决</a></li></ul></li><li><a href=#24-saga aria-label="2.4 SAGA">2.4 SAGA</a></li><li><a href=#25-%e6%9c%ac%e5%9c%b0%e6%b6%88%e6%81%af%e8%a1%a8 aria-label="2.5 本地消息表">2.5 本地消息表</a></li><li><a href=#26-%e4%ba%8b%e5%8a%a1%e6%b6%88%e6%81%af aria-label="2.6 事务消息">2.6 事务消息</a></li><li><a href=#27-%e6%9c%80%e5%a4%a7%e5%8a%aa%e5%8a%9b%e9%80%9a%e7%9f%a5 aria-label="2.7 最大努力通知">2.7 最大努力通知</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const e=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${e}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=1-事务与分布式事务>1. 事务与分布式事务<a hidden class=anchor aria-hidden=true href=#1-事务与分布式事务>#</a></h2><h3 id=11-事务>1.1 事务<a hidden class=anchor aria-hidden=true href=#11-事务>#</a></h3><p>事务是数据库管理系统执行过程中的一个逻辑单元，能够保证一个事务中所有操作要么全部执行，要么全不执行。</p><p>数据库事务拥有四个特性 ACID，分别为 Atomicity 原子性、Consistency 一致性、Isolation 隔离性、Durability 持久性。</p><h3 id=12-分布式事务>1.2 分布式事务<a hidden class=anchor aria-hidden=true href=#12-分布式事务>#</a></h3><p>分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的<strong>不同节点</strong>上。一个流程操作不取决于本地的数据库操作。分布式事务就是为了保证不同数据库的一致性。</p><p>分布式事务之所以复杂，一个主要原因是同一个事务之间的执行多段代码会因为网络的不稳定造成失败等问题。当通过网络请求其他服务的接口时，可能得到 正确、失败、超时 三种结果。无论成功或失败都能得到唯一确定的结果，但是超时却不能确定接收者是否成功处理了请求，而这也成为造成诸多问题的诱因。系统之间的通信可靠性从单一系统中的可靠变成了微服务结构之间的不可靠，分布式事务其实就是在不可靠的通信下实现事务的特性。</p><h3 id=13-分布式事务基础一致性>1.3 分布式事务基础：一致性<a hidden class=anchor aria-hidden=true href=#13-分布式事务基础一致性>#</a></h3><ul><li><p>强一致性</p><ul><li>任何一次都能读到某个数据的最近一次写数据。系统中的所有进程，看到的操作顺序，都和全局时钟下的顺序一致。任意时刻，所有节点中的数据都是一样的。</li></ul></li><li><p>弱一致性</p><ul><li>数据更新后，如果能容忍后序的访问只能访问到部分或者全部访问不到，则是弱一致性。</li></ul></li><li><p>最终一致性</p><ul><li>不保证在任意时刻任意节点上的同一份数据都相同的，但是随着时间的推移，不同节点上的同一份数据总是在向趋同的方向变化。一段时间后，节点间的数据会最终达到一致状态。</li></ul></li></ul><h3 id=14-分布式事务基础cap-原则>1.4 分布式事务基础：CAP 原则<a hidden class=anchor aria-hidden=true href=#14-分布式事务基础cap-原则>#</a></h3><p>CAP 原则又称为 CAP 定理，指在一个分布式系统中，Consistency 一致性、Availability 可用性、Partition-tolerance 分区容错性 三者不可兼得。</p><ul><li>Consistency 一致性：在分布式系统中的所有数据备份，在同一时刻是否同样的值（等同于所有节点访问同一份最新的数据副本）</li><li>Availability 可用性：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求（对数据更新具备高可用性）</li><li>Partition-tolerance 分区容错性：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。</li></ul><p>CAP 三者取舍</p><ul><li>CA：优先保证一致性和可用性，放弃系统扩展性，系统不再是分布式</li><li>CP：优先保证一致性和分区容错性，在一致性要求较高的场合比较常见 Zookeeper，HBase；一旦发生网络故障或消息丢失，会牺牲用户体验，恢复后才逐渐能访问</li><li>AP：优先保证可用性和分区容错性，如 RocketMQ 的 那么server，SpringCloud 的 Eureka</li></ul><p>分布式事务会部分遵循 ACID 规范</p><ul><li>原子性：严格遵循</li><li>一致性：事务完成后的一致性严格遵循；事务中的一致性可适当放宽</li><li>隔离性：并行事务间不可影响；事务中间结果可见性允许安全放宽</li><li>持久性：严格遵循</li></ul><p>因为事务过程中，不是一致的，但事务会最终完成，最终达到一致，所以我们把分布式事务称为“最终一致”</p><h3 id=15-分布式事务基础base-理论>1.5 分布式事务基础：BASE 理论<a hidden class=anchor aria-hidden=true href=#15-分布式事务基础base-理论>#</a></h3><p>BASE aka Basically Availability Soft State Eventual Consistency</p><ul><li>Basically Availability 基本可用：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用</li><li>Soft State 软状态：允许系统存在中间状态，而该中间状态不会影响系统整体可用性</li><li>Eventual Consistency 最终一致性：系统中的所有数据副本经过一定时间后，最终能够达到一致的状态</li></ul><p>BASE 理论本质上是对 CAP 理论的延伸，是对 AP 方案的一个补充</p><h3 id=16-cp--ha>1.6 CP + HA<a hidden class=anchor aria-hidden=true href=#16-cp--ha>#</a></h3><p>分布式事务是在分布式环境下，遵循CAP理论，在CAP三者中只能够三选二，那么分布式事务是那种的组合呢？分布式事务是CP+HA，其中A是没有完全符合，但是能够达到Highly-Available，即高可用。</p><p>近些年分布式理论进一步发展，产生了Paxos、Raft等CP的协议，在这基础上，加上硬件稳定性升级，可以在保证CP的情况下，做到高可用。谷歌分布式锁Chubby的公开数据显示，集群能提供99.99958％的平均可用性，一年也就130s的运行中断，已经能够满足非常严苛的应用要求。现在的SQL类数据库软件，都是走CP+HA，只是HA会比谷歌的这个极致数据更低一些，但一般都能够达到4个9</p><p>CP+HA意味着不是BASE，意味着你只要写入成功，那么接下来的读，能够读取到最新的结果，开发人员不用担心读取到的不是最新数据，在多副本读写上面，与单机是一致的。</p><h2 id=2-分布式事务解决方案>2. 分布式事务解决方案<a hidden class=anchor aria-hidden=true href=#2-分布式事务解决方案>#</a></h2><h3 id=21-xa-2pc>2.1 XA (2PC)<a hidden class=anchor aria-hidden=true href=#21-xa-2pc>#</a></h3><p>XA 规范是 X/Open 组织定义的分布式事务处理 Distributed Transaction Processing 标准。XA 事务由一个或多个资源管理器（RM）、一个事务管理器（TM）和一个应用程序（ApplicationProgram）组成。</p><p>XA 规范描述了全局的事务管理器与局部的资源管理器之间的接口。XA 规范的目的是允许的多个资源（数据库、应用服务器、消息队列等）在同一事务中访问，这样可以使 ACID 属性跨越应用程序而保持有效。XA 规范主要定义了(全局)事务管理器(TM)和(局部)资源管理器(RM)之间的接口。本地的数据库如 mysql 在 XA 中扮演的是 RM 角色。</p><p>XA 规范使用两阶段提交（2PC Two-Phase Commit）来保证所有资源同时提交或回滚任何特定的事务。</p><p>XA 流程</p><ul><li>阶段一 Prepare：事务管理器向所有本地资源管理器发送请求，询问是否处于 ready 状态，所有参与者都将本事务是否成功的信息反馈发给协调者。即所有的参与者 RM 准备执行事务并锁住需要的资源。参与者 ready 时，向 TM 报告已准备就绪。</li><li>阶段二 Commit / Rollback：当事务管理者(TM)确认所有参与者(RM)都ready后，向所有参与者发送commit命令。事务管理器根据所有本地资源管理器的反馈，通知所有本地资源管理器，步调一致地在所有分支上提交或者回滚。</li></ul><p>目前主流的数据库基本都支持XA事务，包括mysql、oracle、sqlserver、postgre。</p><img src=https://s3.us-west-1.amazonaws.com/images.hypertars.com/transaction/51f8112e8b51125a86f8b0508d63394.jpg width=300 align=center><p>优点</p><ul><li>对业务侵⼊很小，它最⼤的优势就是对使⽤⽅透明，用户可以像使⽤本地事务⼀样使⽤基于 XA 协议的分布式事务，能够严格保障事务 ACID 特性。</li></ul><p>缺点</p><ul><li>同步阻塞：当参与事务者存在占用公共资源的情况，其中一个占用了资源，其他事务参与者就只能阻塞等待资源释放，处于阻塞状态。对资源进行了长时间的锁定，并发度低。</li><li>单点故障：一旦事务管理器出现故障，整个系统不可用</li><li>数据不一致：在阶段二，如果事务管理器只发送了部分 commit 消息，此时网络发生异常，那么只有部分参与者接收到 commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</li><li>不确定性：当协事务管理器发送 commit 之后，并且此时只有一个参与者收到了 commit，那么当该参与者与事务管理器同时宕机之后，重新选举的事务管理器无法确定该条消息是否提交成功。</li><li>XA要求数据库本身提供对规范和协议的支持</li></ul><h3 id=22-at>2.2 AT<a hidden class=anchor aria-hidden=true href=#22-at>#</a></h3><p>AT 对业务代码完全无侵入性，使用非常简单，改造成本低。我们只需要关注自己的业务SQL，AT模式下框架会通过分析我们业务SQL，反向生成回滚数据。</p><p>AT 包含两个阶段</p><ul><li>一阶段，所有参与事务的分支，本地事务Commit 业务数据和回滚日志（undoLog）</li><li>二阶段，事务协调者根据所有分支的情况，决定本次全局事务是Commit 还是 Rollback（二阶段是完全异步）</li></ul><p>核心流程</p><ul><li>为每个事务参与者的数据库创建一个 undo log 表，用于记录 DML SQL 执行前的行记录</li><li>每个事务参与者实际执行 DML SQL 时，生成修改前数据插入到 undo log 表中</li></ul><p>流程图</p><img src=https://s3.us-west-1.amazonaws.com/images.hypertars.com/transaction/af6fd7c9457e5b923544250c1c16473.jpg width=600 align=center><p>拓扑图</p><img src=https://s3.us-west-1.amazonaws.com/images.hypertars.com/transaction/4802c79f2beea533508e4d1d0aa925c.jpg width=600 align=center><p>优点</p><ul><li>该事务模式使用方式，类似XA模式，业务无需编写各类补偿操作，回滚由框架自动完成</li></ul><p>缺点</p><ul><li>也类似XA，存在较长时间的锁，不满足高并发的场景。从性能的角度看，AT模式会比XA更高一些，但也带来了脏回滚这样的新问题。</li></ul><h3 id=23-tcc>2.3 TCC<a hidden class=anchor aria-hidden=true href=#23-tcc>#</a></h3><p>TCC 完整语义 Try-Confirm-Cancel</p><ul><li>Try：尝试执行，完成所有业务检查（一致性），预留必须业务资源（准隔离性），如加锁，加标记字段。TCC事务机制中的业务逻辑（Try），从执行阶段来看，与传统事务机制中业务逻辑相同。但从业务角度来看，却不一样。TCC机制中的Try仅是一个初步操作，它和后续的确认一起才能真正构成一个完整的业务逻辑。TCC机制将传统事务机制中的业务逻辑一分为二，拆分后保留的部分即为初步操作（Try）；而分离出的部分即为确认操作（Confirm），被延迟到事务提交阶段执行。TCC事务机制以初步操作（Try）为中心的，确认操作（Confirm）和取消操作（Cancel）都是围绕初步操作（Try）而展开。因此，Try阶段中的操作，其保障性是最好的，即使失败，仍然有取消操作（Cancel）可以将其不良影响进行回撤。可以认为</li></ul><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>[传统事务机制]的业务逻辑 = [TCC事务机制]的初步操作（Try） + [TCC事务机制]的确认逻辑（Confirm）。
</span></span></code></pre></td></tr></table></div></div><ul><li>Confirm：真正确认执行业务，不做任务业务检查，只用 Try 阶段预留的业务资源；操作必须满足幂等性，失败后需要进行重试。确认操作（Confirm）是对初步操作（Try）的一个补充。当TCC事务管理器决定commit全局事务时，就会逐个执行初步操作（Try）指定的确认操作（Confirm），将初步操作（Try）未完成的事项最终完成。</li><li>Cancel：取消执行，释放 Try 阶段预留的业务资源；操作必须满足幂等性，异常处理和 Confirm 一致。取消操作（Cancel）是对初步操作（Try）的一个回撤。当TCC事务管理器决定rollback全局事务时，就会逐个执行初步操作（Try）指定的取消操作（Cancel），将初步操作（Try）已完成的事项全部撤回。</li></ul><img src=https://s3.us-west-1.amazonaws.com/images.hypertars.com/transaction/c93435a3c9fec4942e3e0bac4f23ace.jpg width=600 align=center>
<img src=https://s3.us-west-1.amazonaws.com/images.hypertars.com/transaction/tcc_normal.dea14fb3.jpg width=600 align=center><p>在 Try 阶段，对业务系统进行检查及资源预览，比如订单和存储操作，需要检查库存剩余数量是否够用，并进行预留，预留操作的话就是新建一个可用库存数量字段，Try 阶段操作是对这个可用库存数量进行操作。</p><p>基于 TCC 实现分布式事务，会将原来只需要一个接口就可以实现的逻辑拆分为 Try、Confirm、Cancel 三个接口，所以代码实现复杂度相对较高，对业务的侵入性大。</p><p>TCC的Confirm/Cancel阶段在业务逻辑上是不允许返回失败的，如果因为网络或者其他临时故障，导致不能返回成功，TM会不断的重试，直到Confirm/Cancel返回成功。</p><p>TCC特点如下</p><ul><li>并发度较高，无长期资源锁定。</li><li>开发量较大，需要提供Try/Confirm/Cancel接口。</li><li>一致性较好，不会发生SAGA已扣款最后又转账失败的情况</li><li>TCC适用于订单类业务，对中间状态有约束的业务</li></ul><h4 id=tcc-和-2pc>TCC 和 2PC？<a hidden class=anchor aria-hidden=true href=#tcc-和-2pc>#</a></h4><p>TCC 并不是 2PC 的一种。2PC 需要 RM 提供底层支持（一般是兼容 XA），而 TCC 不需要。对于传统事务机制 X/Open XA 2PC，其特征在于它不依赖资源管理器 Resource Manager 对 XA 的支持，而是通过对（由业务系统提供的）业务逻辑的调度来实现分布式事务。</p><p>对于业务系统中一个特定的业务逻辑S，其对外提供服务时，必须接受一些不确定性，即对业务逻辑执行的一次调用仅是一个临时性操作，调用它的消费方服务M保留了后续的取消权。如果M认为全局事务应该rollback，它会要求取消之前的临时性操作，这将对应S的一个取消操作；而当M认为全局事务应该commit时，它会放弃之前临时性操作的取消权，这对应S的一个确认操作。</p><p>每一个初步操作，最终都会被确认或取消。因此，针对一个具体的业务服务，TCC事务机制需要业务系统提供三段业务逻辑：初步操作Try、确认操作Confirm、取消操作Cancel。</p><p>TCC 在事务处理上，要么调用 confirm，要么调用 cancel；try 逻辑与全局事务无关。
使用 2PC 时完整的事务生命周期是：begin -> 业务逻辑 -> prepare -> commit
使用 TCC 时完整的事务生命周期是：begin -> 业务逻辑 (try) -> commit (confirm 业务)</p><p>在执行阶段可以将二者一一对应</p><ol><li>2PC 业务阶段 - TCC try 业务阶段</li><li>2PC 提交阶段 (prepare & commit) - TCC confirm 提交阶段</li><li>2PC 回滚阶段 (rollback) - TCC cancel 回滚阶段</li></ol><p>TCC 不是 2PC，只是它对事务的 提交/回滚 是通过执行一段 confirm/cancel 业务逻辑来实现而已。</p><h4 id=tcc-事务管理器协调者设计>TCC 事务管理器协调者设计<a hidden class=anchor aria-hidden=true href=#tcc-事务管理器协调者设计>#</a></h4><p>TCC全局事务必须基于 RM 本地事务来实现全局事务</p><ul><li>Try/Confirm/Cancel业务在执行时，会访问资源管理器（Resource Manager，下文简称RM）来存取数据。这些存取操作，必须要参与RM本地事务，以使其更改的数据要么都commit，要么都rollback。</li><li>分布式事务管理框架的职责，不是做出全局事务提交/回滚的指令，而是管理全局事务提交/回滚的过程。</li></ul><p>实际实现中：</p><ul><li>只实现 try cancel 就是一个 SAGA<ul><li>一般扣除类动作，try 时即扣除，cancel 时补偿，confirm 为空；因为 confirm 时再完成扣除可能已经余额不足，因此要求 confirm 一定成功。</li><li>但是发放类动作，一般不适用 SAGA，因为 cancel 前可能已经被消耗，导致无法回滚，此时必须用 TCC 语义在 confirm 时是肌肤放。</li></ul></li><li>只实现 try confirm 就是一个 XA</li></ul><h4 id=tcc-语义与问题解决>TCC 语义与问题解决<a hidden class=anchor aria-hidden=true href=#tcc-语义与问题解决>#</a></h4><p>子事务接口约束</p><ul><li>中间态设计：try 成功后，confirm / cancel 必须成功</li><li>try / confirm / cancel 幂等</li><li>cancel 允许空回滚</li><li>cancel 允许请求倒挂（try 悬挂）</li></ul><p>问题：Try 超时（空回滚）</p><ul><li>Cancel 接口设计时允许空回滚。在 try 接口因为丢包没有收到时，事务管理器会触发回滚，这时会出发 Cancel 接口，若发现没有对应事务的 xid 或主键时，需要返回回滚成功。让事务服务管理器认为已回滚，否则会不断重试。</li></ul><p>问题：Confirm / Cancel 超时</p><ul><li>因为网络抖动或拥堵可能超时，事务管理器会对资源进行重试操作，为了不因为重复调用而多次占用资源，设计时进行幂等控制。</li></ul><p>问题：Try 比 Cancel 晚到达（try 悬挂）</p><ul><li>Cancel 比 try 先执行，事务管理器生成回滚，而之后收到了 try 接口调用。此时 try 接口因 cancel 已执行而不再执行，否则产生数据不一致。所以在 try 前先检查该事务 xid 或业务主键，如果已经标记为回滚成功过，就不再执行 try 的业务操作。</li></ul><h3 id=24-saga>2.4 SAGA<a hidden class=anchor aria-hidden=true href=#24-saga>#</a></h3><p>SAGA事务，其核心思想是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。每个参与者都定义一个正向行为（变更）和一个反向行为（补偿），分布式事务按照既定顺序执行正向行为直到全部成功（提交），如果中间发生错误，则逆序执行对应的反向行为（回滚）。</p><img src=https://s3.us-west-1.amazonaws.com/images.hypertars.com/transaction/c3c2e817f0bf42add72f78a2a8dc294.jpg width=300 align=center><p>SAGA 执行流程如下</p><ul><li>分支事务 1 到 N 依次执行成功，全局事务成功</li><li>分支事务 i 执行失败，从分支事务 i 倒序至分支事务 1，依次执行补偿，失败则重试，补偿需幂等（回滚优先策略）</li><li>分支事务 i 执行失败，重试直到成功，然后依次执行后序分支事务，正向操作保障幂等（重试优先策略）</li></ul><p>适用场景</p><ul><li>业务流程长、业务流程多</li><li>长事务适用，对中间结果不敏感的业务场景适用</li><li>参与者包含其它公司或遗留系统服务，无法提供 TCC 模式要求的三个接口</li></ul><p>优势</p><ul><li>并发度高，不用像XA事务那样长期锁定资源</li><li>一阶段提交本地事务，无锁，高性能</li><li>事件驱动架构，参与者可异步执行，高吞吐</li><li>需要定义正常操作以及补偿操作，开发量比XA大，但是补偿服务易于实现</li><li>相较于 TCC 业务侵入度适中</li></ul><p>缺点</p><ul><li>不保证隔离性</li><li>一致性较弱，对于转账，可能发生A用户已扣款，最后转账又失败的情况</li></ul><h3 id=25-本地消息表>2.5 本地消息表<a hidden class=anchor aria-hidden=true href=#25-本地消息表>#</a></h3><p>本地消息表方案中会有消息生产者与消费者两个角色，假设服务 A 是消息的生产者，服务 B 是消息的消费者。写本地消息和业务操作放在一个事务里，保证了业务和发消息的原子性，要么他们全都成功，要么全都失败。此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。</p><img src=https://s3.us-west-1.amazonaws.com/images.hypertars.com/transaction/6e53c9445d82d72851e9c747ed25f0f.jpg width=600 align=center><ul><li>当服务 A 被其他服务调用发生数据库表更操作，首先会更新该服务数据库的业务表，其次会往相同数据库的消息表中插入一条数据，两个操作发生在同一个事务中</li><li>服务 A 的脚本定期轮询本地消息往 mq 中写入一条消息，如果消息发送失败会进行重试</li><li>服务 B 消费 mq 中的消息，并处理业务逻辑。如果本地事务处理失败，会在继续消费 mq 中的消息进行重试，如果业务上的失败，可以通知服务 A 进行回滚操作，或进行告警通知相关人员进行处理。</li></ul><p>本地消息表的实现条件</p><ul><li>消费者与生成者的接口都要幂等</li><li>生产者需要额外的创建消息记录表</li><li>可能需要提供补偿逻辑，如果消费者业务失败，生产者可支持回滚操作</li><li>进行重试或进行业务逻辑告警，通过人工介入的方式处理。</li></ul><p>适用场景</p><ul><li>可异步执行的业务，且后续操作无需回滚的业务</li></ul><p>容错机制</p><ul><li>扣减余额事务 失败时，事务直接回滚，无后续步骤</li><li>轮序生产消息失败， 增加余额事务失败都会进行重试</li></ul><p>本地消息表的特点</p><ul><li>不支持回滚</li><li>轮询生产消息难实现，如果定时轮询会延长事务总时长，如果订阅binlog则开发维护困难</li><li>适用于可异步执行的业务，且后续操作无需回滚的业务</li></ul><h3 id=26-事务消息>2.6 事务消息<a hidden class=anchor aria-hidden=true href=#26-事务消息>#</a></h3><p>在上述的本地消息表方案中，生产者需要额外创建消息表，还需要对本地消息表进行轮询，业务负担较重。阿里开源的RocketMQ 4.3之后的版本正式支持事务消息，该事务消息本质上是把本地消息表放到RocketMQ上，解决生产端的消息发送与本地事务执行的原子性问题。</p><p>事务消息发送及提交</p><ul><li>发送消息（half消息）</li><li>服务端存储消息，并响应消息的写入结果</li><li>根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）</li><li>根据本地事务状态执行Commit或者Rollback（Commit操作发布消息，消息对消费者可见）</li></ul><p>补偿流程</p><ul><li>对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”</li><li>Producer收到回查消息，返回消息对应的本地事务的状态，为Commit或者Rollback</li><li>事务消息方案与本地消息表机制非常类似，区别主要在于原先相关的本地表操作替换成了一个反查接口</li></ul><p>事务消息特点</p><ul><li>长事务仅需要分拆成多个任务，并提供一个反查接口，使用简单</li><li>事务消息的回查没有好的方案，极端情况可能出现数据错误</li><li>适用于可异步执行的业务，且后续操作无需回滚的业务</li></ul><p>适用场景</p><ul><li>可异步执行的业务，且后续操作无需回滚的业务</li></ul><h3 id=27-最大努力通知>2.7 最大努力通知<a hidden class=anchor aria-hidden=true href=#27-最大努力通知>#</a></h3><p>发起通知方通过一定的机制最大努力将业务处理结果通知到接收方。具体包括：</p><ul><li>有一定的消息重复通知机制。因为接收通知方可能没有接收到通知，此时要有一定的机制对消息重复通知。</li><li>消息校对机制。如果尽最大努力也没有通知到接收方，或者接收方消费消息后要再次消费，此时可由接收方主动向通知方查询消息信息来满足需求。</li></ul><p>前面的本地消息表和事务消息都属于可靠消息，与这里的最大努力通知有什么不同？</p><ul><li>可靠消息一致性，发起通知方需要保证将消息发出去，并且将消息发到接收通知方，消息的可靠性关键由发起通知方来保证。</li><li>最大努力通知，发起通知方尽最大的努力将业务处理结果通知为接收通知方，但是可能消息接收不到，此时需要接收通知方主动调用发起通知方的接口查询业务处理结果，通知的可靠性关键在接收通知方。</li></ul><p>解决方案上，最大努力通知需要：</p><ul><li>提供接口，让接受通知放能够通过接口查询业务处理结果</li><li>消息队列ACK机制，消息队列按照间隔1min、5min、10min、30min、1h、2h、5h、10h的方式，逐步拉大通知间隔 ，直到达到通知要求的时间窗口上限。之后不再通知</li></ul><p>适用类型</p><ul><li>业务通知类型，例如微信交易的结果，就是通过最大努力通知方式通知各个商户，既有回调通知，也有交易查询接口</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.hypertars.com/tags/distributed-system/>Distributed System</a></li><li><a href=https://blog.hypertars.com/tags/distributed-transaction/>Distributed Transaction</a></li><li><a href=https://blog.hypertars.com/tags/cap/>CAP</a></li><li><a href=https://blog.hypertars.com/tags/base/>BASE</a></li><li><a href=https://blog.hypertars.com/tags/xa/>XA</a></li><li><a href=https://blog.hypertars.com/tags/tcc/>TCC</a></li><li><a href=https://blog.hypertars.com/tags/saga/>SAGA</a></li></ul><nav class=paginav><a class=prev href=https://blog.hypertars.com/posts/developer/distributed_systems/zab/><span class=title>« Prev Page</span><br><span>ZAB 原子广播协议</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 分布式事务 on twitter" href="https://twitter.com/intent/tweet/?text=%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1&url=https%3a%2f%2fblog.hypertars.com%2fposts%2fdeveloper%2fdistributed_systems%2ftransaction%2f&hashtags=DistributedSystem%2cDistributedTransaction%2cCAP%2cBASE%2cXA%2cTCC%2cSAGA"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 分布式事务 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fblog.hypertars.com%2fposts%2fdeveloper%2fdistributed_systems%2ftransaction%2f&title=%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1&summary=%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1&source=https%3a%2f%2fblog.hypertars.com%2fposts%2fdeveloper%2fdistributed_systems%2ftransaction%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 分布式事务 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fblog.hypertars.com%2fposts%2fdeveloper%2fdistributed_systems%2ftransaction%2f&title=%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 分布式事务 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.hypertars.com%2fposts%2fdeveloper%2fdistributed_systems%2ftransaction%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 分布式事务 on whatsapp" href="https://api.whatsapp.com/send?text=%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1%20-%20https%3a%2f%2fblog.hypertars.com%2fposts%2fdeveloper%2fdistributed_systems%2ftransaction%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 分布式事务 on telegram" href="https://telegram.me/share/url?text=%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1&url=https%3a%2f%2fblog.hypertars.com%2fposts%2fdeveloper%2fdistributed_systems%2ftransaction%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>